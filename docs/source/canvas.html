<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(jQuery) {
&quot;use strict&quot;;

var $ = jQuery;

var canvas = Echo.Control.manifest(&quot;Echo.Canvas&quot;);

if (Echo.Control.isDefined(canvas)) return;

<span id='Echo-Canvas-method-constructor'><span id='Echo-Canvas'>/**
</span></span> * @class Echo.Canvas
 * Class which implements Canvas mechanics on the client side.
 * The instance of this class is created for each Canvas found on the page by
 * the Echo.Loader. The instance of the class can also be created manually in
 * case the Canvas data already exists on the page.
 *
 * @package environment.pack.js
 *
 * @extends Echo.Control
 *
 * @constructor
 * Canvas object constructor to initialize the Echo.Canvas instance
 *
 * @param {Object} config
 * Configuration options
 */

<span id='Echo-Canvas-method-getRelativeTime'>/** @hide @method getRelativeTime */
</span><span id='Echo-Canvas-echo_label-justNow'>/** @hide @echo_label justNow */
</span><span id='Echo-Canvas-echo_label-today'>/** @hide @echo_label today */
</span><span id='Echo-Canvas-echo_label-yesterday'>/** @hide @echo_label yesterday */
</span><span id='Echo-Canvas-echo_label-lastWeek'>/** @hide @echo_label lastWeek */
</span><span id='Echo-Canvas-echo_label-lastMonth'>/** @hide @echo_label lastMonth */
</span><span id='Echo-Canvas-echo_label-secondAgo'>/** @hide @echo_label secondAgo */
</span><span id='Echo-Canvas-echo_label-secondsAgo'>/** @hide @echo_label secondsAgo */
</span><span id='Echo-Canvas-echo_label-minuteAgo'>/** @hide @echo_label minuteAgo */
</span><span id='Echo-Canvas-echo_label-minutesAgo'>/** @hide @echo_label minutesAgo */
</span><span id='Echo-Canvas-echo_label-hourAgo'>/** @hide @echo_label hourAgo */
</span><span id='Echo-Canvas-echo_label-hoursAgo'>/** @hide @echo_label hoursAgo */
</span><span id='Echo-Canvas-echo_label-dayAgo'>/** @hide @echo_label dayAgo */
</span><span id='Echo-Canvas-echo_label-daysAgo'>/** @hide @echo_label daysAgo */
</span><span id='Echo-Canvas-echo_label-weekAgo'>/** @hide @echo_label weekAgo */
</span><span id='Echo-Canvas-echo_label-weeksAgo'>/** @hide @echo_label weeksAgo */
</span><span id='Echo-Canvas-echo_label-monthAgo'>/** @hide @echo_label monthAgo */
</span><span id='Echo-Canvas-echo_label-monthsAgo'>/** @hide @echo_label monthsAgo */
</span><span id='Echo-Canvas-echo_label-loading'>/** @hide @echo_label loading */
</span><span id='Echo-Canvas-echo_label-retrying'>/** @hide @echo_label retrying */
</span><span id='Echo-Canvas-echo_label-error_busy'>/** @hide @echo_label error_busy */
</span><span id='Echo-Canvas-echo_label-error_timeout'>/** @hide @echo_label error_timeout */
</span><span id='Echo-Canvas-echo_label-error_waiting'>/** @hide @echo_label error_waiting */
</span><span id='Echo-Canvas-echo_label-error_view_limit'>/** @hide @echo_label error_view_limit */
</span><span id='Echo-Canvas-echo_label-error_view_update_capacity_exceeded'>/** @hide @echo_label error_view_update_capacity_exceeded */
</span><span id='Echo-Canvas-echo_label-error_result_too_large'>/** @hide @echo_label error_result_too_large */
</span><span id='Echo-Canvas-echo_label-error_wrong_query'>/** @hide @echo_label error_wrong_query */
</span><span id='Echo-Canvas-echo_label-error_incorrect_appkey'>/** @hide @echo_label error_incorrect_appkey */
</span><span id='Echo-Canvas-echo_label-error_internal_error'>/** @hide @echo_label error_internal_error */
</span><span id='Echo-Canvas-echo_label-error_quota_exceeded'>/** @hide @echo_label error_quota_exceeded */
</span><span id='Echo-Canvas-echo_label-error_incorrect_user_id'>/** @hide @echo_label error_incorrect_user_id */
</span><span id='Echo-Canvas-echo_label-error_unknown'>/** @hide @echo_label error_unknown */
</span>
<span id='Echo-Canvas-echo_event-onReady'>/**
</span> * @echo_event Echo.Canvas.onReady
 * Triggered when the app initialization is finished completely.
 */
<span id='Echo-Canvas-echo_event-onRefresh'>/**
</span> * @echo_event Echo.Canvas.onRefresh
 * Triggered when the app is refreshed. For example after the user
 * login/logout action or as a result of the &quot;refresh&quot; function call.
 */
<span id='Echo-Canvas-echo_event-onRender'>/**
</span> * @echo_event Echo.Canvas.onRender
 * Triggered when the app is rendered.
 */
<span id='Echo-Canvas-echo_event-onRerender'>/**
</span> * @echo_event Echo.Canvas.onRerender
 * Triggered when the app is rerendered.
 */

canvas.init = function() {
	var ids, cssClass;
	var self = this, target = this.config.get(&quot;target&quot;);

	// check if the canvas was already initialized
	if (target.data(&quot;echo-canvas-initialized&quot;)) {
		this._error({
			&quot;args&quot;: {&quot;target&quot;: target},
			&quot;code&quot;: &quot;canvas_already_initialized&quot;
		});
		return;
	}

	// define initialized state for the canvas
	// to prevent multiple initialization of the same canvas
	target.data(&quot;echo-canvas-initialized&quot;, true);

	// extending Canvas config with the parameters defined in the target
	var overrides = this._getOverrides(target, [
		&quot;id&quot;,
		&quot;mode&quot;,
		&quot;provider&quot;,
		&quot;useSecureAPI&quot;,
		&quot;appsInit&quot;,
		&quot;maxConfigFetchingRetries&quot;
	]);
	if (!$.isEmptyObject(overrides)) {
		this.config.extend(overrides);
	}

	if (Echo.Loader.isDebug()) this.config.set(&quot;mode&quot;, &quot;dev&quot;);

	// exit if no &quot;id&quot; is defined for the canvas,
	// skip this validation in case the &quot;data&quot; is defined explicitly in the config
	if (!this._isManuallyConfigured() &amp;&amp; !this.config.get(&quot;id&quot;)) {
		this._error({
			&quot;args&quot;: {&quot;target&quot;: target},
			&quot;code&quot;: &quot;invalid_canvas_config&quot;
		});
		return;
	}

	// apply our canvas id as a CSS class if we aren&#39;t manually configured
	if (this.config.get(&quot;id&quot;)) {
		ids = this._getIds().normalized;
		// adding a primary canvas ID and unique page identifier
		// as a CSS class if provided
		cssClass = Echo.Utils.foldl(&quot;&quot;, [&quot;main&quot;, &quot;unique&quot;], function(type, acc) {
			return (acc += ids[type] ? self.get(&quot;cssPrefix&quot;) + ids[type] + &quot; &quot; : &quot;&quot;);
		});
		target.addClass(cssClass);
	}

	// fetch canvas config from remote storage
	this._fetchConfig(function() {
<span id='Echo-Canvas-echo_event-onDataReceive'>		/**
</span>		 * @echo_event Echo.Canvas.onDataReceive
		 * Event which is triggered when data received from the storage.
		 *
		 * @param {String} topic
		 * Name of the event produced.
		 *
		 * @param {Object} data
		 *
		 * @param {String} data.id
		 * Unique ID of the Canvas.
		 *
		 * @param {Object} data.config
		 * Object which contains received config.
		 */
		self.events.publish({
			&quot;topic&quot;: &quot;onDataReceive&quot;,
			&quot;data&quot;: {
				&quot;id&quot;: self.config.get(&quot;id&quot;),
				&quot;config&quot;: self.get(&quot;data&quot;)
			}
		});
		var backplane = self.get(&quot;data.backplane&quot;);
		if (backplane) {
			Backplane.init(backplane);
		}
		self.updateLayout(this.get(&quot;data.apps&quot;), this.get(&quot;data.layout&quot;)).then(function() {
			self.ready();
		});
	});
};

canvas.config = {
<span id='Echo-Canvas-cfg-appsInit'>	/**
</span>	 * @cfg {String} [appsInit]
	 * This parameter specifies the mode in which applications will be initialized.
	 * There are two possible values for this parameter:
	 *
	 * + &quot;async&quot; - in this case applications initialize simultaneously
	 * + &quot;sync&quot; - in this case applications initialize synchronously one-by-one
	 *
	 * The value of this parameter can be overridden by specifying the &quot;data-canvas-appsInit&quot;
	 * target DOM element attribute.
	 * More information about HTML attributes of the target DOM element can be found [here](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 */
	&quot;appsInit&quot;: &quot;async&quot;,

<span id='Echo-Canvas-cfg-appInitTimeout'>	/**
</span>	 * @cfg {Number} [appInitTimeout]
	 * This parameter specifies the interval in milliseconds in which
	 * each application can be executed during initialization process.
	 *
	 * The value of this parameter can be overridden by specifying the &quot;data-canvas-appInitTimeout&quot;
	 * target DOM element attribute.
	 * More information about HTML attributes of the target DOM element can be found [here](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 */
	&quot;appInitTimeout&quot;: 5000,

<span id='Echo-Canvas-cfg-id'>	/**
</span>	 * @cfg {String} [id]
	 * Unique ID of the Canvas, used by the Echo.Canvas instance
	 * to retrieve the data from the Canvases data storage.
	 */
	&quot;id&quot;: &quot;&quot;,

<span id='Echo-Canvas-cfg-data'>	/**
</span>	 * @cfg {Object} [data]
	 * Object which contains the Canvas data in the format
	 * used to store the Canvas config in the Canvas storage.
	 */
	&quot;data&quot;: {},

<span id='Echo-Canvas-cfg-target'>	/**
</span>	 * @cfg {String} target(required)
	 * Specifies the DOM element where the control will be displayed.
	 *
	 * Note: if only the &quot;target&quot; config parameter is defined, the target DOM element
	 * should contain the following HTML attribute:
	 *
	 * + &quot;data-canvas-id&quot; with the unique Canvas ID which should be initialized
	 *
	 * The values of the HTML parameters override the &quot;id&quot; parameter value
	 * (respectively) passed via the Canvas config.
	 */

<span id='Echo-Canvas-cfg-overrides'>	/**
</span>	 * @cfg {Object} [overrides]
	 * Object which contains the overrides applied for this Canvas on the page
	 * via Echo.Loader.override function call.
	 */
	&quot;overrides&quot;: {},

<span id='Echo-Canvas-cfg-mode'>	/**
</span>	 * @cfg {String} [mode]
	 * This parameter specifies the mode in which Canvas works.
	 * There are two possible values for this parameter:
	 *
	 * + &quot;dev&quot; - in this case the Canvas works with the development configuration storage
	 * + &quot;prod&quot; - in this case the Canvas works with the production configuration storage
	 *
	 * More information about defference between production and development configuration
	 * storages can be found in the [&quot;How to deploy an App using a Canvas guide&quot;](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 *
	 * The value of this parameter can be overridden by specifying the &quot;data-canvas-mode&quot;
	 * target DOM element attribute.
	 * More information about HTML attributes of the target DOM element can be found [here](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 */
	&quot;mode&quot;: &quot;prod&quot;,

<span id='Echo-Canvas-cfg-maxConfigFetchingRetries'>	/**
</span>	 * @cfg {Number} [maxConfigFetchingRetries]
	 * The number of retries attempts to fetch canvas config.
	 *
	 * The value of this parameter can be overridden by specifying the &quot;data-canvas-maxConfigFetchingRetries&quot;
	 * target DOM element attribute.
	 * More information about HTML attributes of the target DOM element can be found [here](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 */
	&quot;maxConfigFetchingRetries&quot;: 2,

	&quot;provider&quot;: &quot;aws&quot;, // &quot;aws&quot; | &quot;fastly&quot;

<span id='Echo-Canvas-cfg-refreshOnUserInvalidate'>	/**
</span>	 * @cfg {Boolean} refreshOnUserInvalidate=false
	 * @inheritdoc
	 */
	&quot;refreshOnUserInvalidate&quot;: false
};

canvas.vars = {
	&quot;apps&quot;: {}
};

canvas.labels = {
<span id='Echo-Canvas-echo_label-error_no_apps'>	/**
</span>	 * @echo_label
	 */
	&quot;error_no_apps&quot;: &quot;No applications defined for this canvas&quot;,
<span id='Echo-Canvas-echo_label-error_no_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_no_config&quot;: &quot;Unable to retrieve Canvas config&quot;,
<span id='Echo-Canvas-echo_label-error_no_suitable_app_class'>	/**
</span>	 * @echo_label
	 */
	&quot;error_no_suitable_app_class&quot;: &quot;Unable to init an app, no suitable JS class found&quot;,
<span id='Echo-Canvas-echo_label-error_unable_to_retrieve_app_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_unable_to_retrieve_app_config&quot;: &quot;Unable to retrieve Canvas config from the storage&quot;,
<span id='Echo-Canvas-echo_label-error_incomplete_app_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_incomplete_app_config&quot;: &quot;Unable to init an app, config is incomplete&quot;,
<span id='Echo-Canvas-echo_label-error_canvas_already_initialized'>	/**
</span>	 * @echo_label
	 */
	&quot;error_canvas_already_initialized&quot;: &quot;Canvas has been initialized already&quot;,
<span id='Echo-Canvas-echo_label-error_invalid_canvas_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_invalid_canvas_config&quot;: &quot;Canvas with invalid configuration found&quot;
};

<span id='Echo-Canvas-echo_template-main'>/**
</span> * @echo_template
 */
canvas.templates.main =
	&#39;&lt;div class=&quot;{class:container}&quot;&gt;&lt;/div&gt;&#39;;

canvas.templates.row =
	&#39;&lt;div class=&quot;echo-canvas-row&quot; data-type=&quot;row&quot;&gt;&lt;/div&gt;&#39;;

canvas.templates.column =
	&#39;&lt;div class=&quot;echo-canvas-column&quot; data-type=&quot;column&quot;&gt;&lt;/div&gt;&#39;;

<span id='Echo-Canvas-echo_template-app'>/**
</span> * @echo_template
 */
canvas.templates.app =
	&#39;&lt;div class=&quot;{class:appContainer}&quot;&gt;&#39; +
		&#39;&lt;div class=&quot;{class:appHeader}&quot;&gt;&lt;/div&gt;&#39; +
		&#39;&lt;div class=&quot;{class:appBody}&quot;&gt;&lt;/div&gt;&#39; +
	&#39;&lt;/div&gt;&#39;;

canvas.destroy = function() {
	$.map(this.get(&quot;apps&quot;), $.proxy(this._destroyApp, this));
	this.config.get(&quot;target&quot;).data(&quot;echo-canvas-initialized&quot;, false);
	// remove cached canvas config
	Echo.Utils.remove(Echo.Loader.canvasesConfigById, this._getIds().unique);
};

<span id='Echo-Canvas-echo_renderer-container'>/**
</span> * @echo_renderer
 */
canvas.renderers.container = function(element) {
	return this._buildGrid(this.get(&quot;data.apps&quot;, []), this.get(&quot;data.layout&quot;, []), element);
};

<span id='Echo-Canvas-method-updateLayout'>/**
</span> * Canvas layout granular update logic without full refresh.
 *
 * This function performs the following actions:
 *
 * - inits an app if it was added to the Canvas
 * - re-inits an app if the config of that app was changed
 * - destroys an app in case it was deleted from a Canvas
 * - re-arranges target elements in a Canvas if app locations/sizes
 *   were changed
 *
 * @param {Array} apps
 * App list in the format used within the Canvas storage
 *
 * For example:
 *
 * 	[{
 * 		&quot;id&quot;: &quot;appId&quot;,
 * 		&quot;script&quot;: &quot;http://appurl/app.js&quot;,
 * 		&quot;component&quot;: &quot;App.Class&quot;,
 * 		&quot;config&quot;: {
 * 			&quot;key1&quot;: &quot;value1&quot;
 * 		}
 * 	}, {
 * 		&quot;id&quot;: &quot;anotherAppId&quot;,
 * 		&quot;script&quot;: &quot;http://anotherappurl/app.js&quot;,
 * 		&quot;component&quot;: &quot;AnotherApp.Class&quot;,
 * 		&quot;config&quot;: {
 * 			&quot;key2&quot;: &quot;value2&quot;
 * 		}
 * 	}]
 *
 * @param {Array} layout
 * Layout configuration in the format used within the Canvas storage.
 *
 * For example:
 *
 * 	[
 * 		{&quot;col&quot;: 1, &quot;row&quot;: 1, &quot;size_x&quot;: 4, &quot;app&quot;: &quot;appId&quot;},
 * 		{&quot;col&quot;: 2, &quot;row&quot;: 1, &quot;size_x&quot;: 8, &quot;app&quot;: &quot;anotherAppId&quot;}
 * 	]
 *
 * @return {jQuery Deferred&#39;s promise}
 * The Promise object resolves when all apps are initialized and new
 * layout is built
 */
canvas.methods.updateLayout = function(apps, layout) {
	var render = function(apps) {
		this.render();
		return apps;
	};
	this.set(&quot;data.apps&quot;, apps);
	this.set(&quot;data.layout&quot;, layout || []);
	return Echo.Utils.pipe([
		$.proxy(this._loadAppResources, this, apps),
		$.proxy(this._destroyOutdatedApps, this),
		$.proxy(this._prepareAppsView, this),
		$.proxy(render, this),
		$.proxy(this._sortAppsByLayout, this),
		$.proxy(this._initApps, this)
	]);
};

// destroy apps which are initialized but not specified in apps.
canvas.methods._destroyOutdatedApps = function(apps) {
	var self = this;
	$.each(this.apps, function(appId, app) {
		var found = self._indexOfApp(appId, apps) &gt; -1;
		if (!found) self._destroyApp(app);
	});
	return apps;
};

canvas.methods._indexOfApp = function(id, apps) {
	var index = -1;
	$.each(apps, function(i, app) {
		if (id === app.id) {
			index = i;
			return false;
		}
	});
	return index;
};

// since applications can be placed in a row, we want to sort them
// in the order they need to be initialized and visually displayed,
// i.e. left -&gt; right, top -&gt; bottom
canvas.methods._sortAppsByLayout = function(apps) {
	var self = this;
	var layout = this.get(&quot;data.layout&quot;, [])
		.sort(function(a, b) { return a.row - b.row || a.col - b.col; });
	var sorted = Echo.Utils.foldl([], layout, function(item, acc, i) {
		var appId = item.app;
		var index = self._indexOfApp(appId, apps);
		if (index === -1) return acc;
		if (i &gt; 0 &amp;&amp; acc[i - 1]) {
			acc[i] = apps[index];
		} else {
			acc.push(apps[index]);
		}
		apps.splice(index, 1);
		return acc;
	});
	return sorted.concat(apps);
};

canvas.methods._isAppInitRequired = function(app) {
	return !this.apps[app.id] || !this.apps[app.id].instance;
};

canvas.methods._isAppReInitRequired = function(app) {
	return !Echo.Utils.deepEqual(app, this.apps[app.id].data);
};

canvas.methods._initApps = function(apps) {
	var self = this;
	var appsObject = this.apps;
	var initApp = $.proxy(this._initApp, this);
	var reInitApp = $.proxy(this._reInitApp, this);
	var isSyncAppsInit = this.config.get(&quot;appsInit&quot;) === &quot;sync&quot;;

	var iterator = function(init, app) {
		appsObject[app.id].data = $.extend(true, {}, app);
		var wrapper = function() {
			return init(app).done(function(instance) {
				appsObject[app.id].instance = instance;
				return instance;
			});
		};
		return isSyncAppsInit ? wrapper : wrapper();
	};
	var promises = $.map(apps, function(app) {
		if (self._isAppInitRequired(app)) {
			return iterator(initApp, app);
		} else if (self._isAppReInitRequired(app)) {
			return iterator(reInitApp, app);
		}
		return iterator(function() {
			return $.Deferred()
				.resolve(appsObject[app.id].instance)
				.promise();
		}, app);
	});
	return isSyncAppsInit
		? Echo.Utils.pipe(promises)
		: $.when.apply($, promises);
};

canvas.methods._reInitApp = function(app) {
	var obj = {};
	var appContainer = this.apps[app.id];
	obj.view = appContainer.view;
	obj.data = appContainer.data;
	this._destroyApp(this.apps[app.id]);
	this.apps[app.id] = obj;
	return this._initApp(app);
};

canvas.methods._initApp = function(app) {
	var deferred = $.Deferred();
	var Application = Echo.Utils.getComponent(app.component);
	if (!Application) {
		this._error({
			&quot;args&quot;: {&quot;app&quot;: app},
			&quot;code&quot;: &quot;no_suitable_app_class&quot;
		});
		deferred.reject(app);
		return deferred.promise();
	}

	var overrides = this.config.get(&quot;overrides&quot;)[app.id];

	app.config.target = this.apps[app.id].view.get(&quot;appBody&quot;);

	var config = overrides
		? $.extend(true, app.config, overrides)
		: app.config;
	var ready = config.ready || $.noop;
	var timeoutId;
	var resolve = function(instance) {
		clearTimeout(timeoutId);
		return deferred.resolve(instance);
	};

	// determine if Application is the Echo specific
	if (Application._manifest) {
		var instance = new Application(
			$.extend(config, {
				&quot;ready&quot;: function() {
					ready.apply(this, arguments);
					resolve(this);
				}
			})
		);
		timeoutId = setTimeout(function() {
			resolve(instance);
		}, this.config.get(&quot;appInitTimeout&quot;));
	} else {
		resolve(new Application(config));
	}

	return deferred.promise();
};

canvas.methods._normalizeApp = function(app) {
	return $.extend(true, {
		&quot;id&quot;: Echo.Utils.getUniqueString(),
		&quot;config&quot;: {
			&quot;canvasId&quot;: this.config.get(&quot;id&quot;)
		}
	}, app);
};

canvas.methods._prepareAppsView = function(apps) {
	var self = this;
	return $.map(apps, function(app) {
		app = self._normalizeApp(app);
		if (self._isAppInitRequired(app) || self._isAppReInitRequired(app)) {
			var appClassName = self.get(&quot;cssPrefix&quot;) + &quot;appId-&quot; + app.id;
			var view = self.view.fork({
				&quot;renderer&quot;: null,
				&quot;renderers&quot;: {
					&quot;appHeader&quot;: function(element) {
						return app.caption
							? element.text(Echo.Utils.sanitize(app.caption, &quot;plainText&quot;)).show()
							: element.hide();
					},
					&quot;appBody&quot;: function(element) {
						return element.addClass(appClassName);
					}
				}
			});

			view.render({
				&quot;data&quot;: app,
				&quot;template&quot;: self.templates.app
			});

			self.apps[app.id] = self.apps[app.id] || {};
			self.apps[app.id].view = view;
		}
		return app;
	});
};

canvas.methods._buildGrid = function(apps, grid, container) {
	var self = this;
	var totalColumns = Math.max.apply(null, $.map(grid, function(item) {
		return item.col + item.size_x - 1;
	}).concat(0));
	var toMatrix = function(grid) {
		return Echo.Utils.foldl([], grid, function(item, acc, k) {
			if (!acc[item.row - 1]) acc[item.row - 1] = [];
			acc[item.row - 1][item.col - 1] = $.extend({}, item, {
				&quot;row&quot;: item.row - 1,
				&quot;col&quot;: item.col - 1
			});
		});
	};

	var getItemsBelow = function(matrix, cell) {
		var result = [];
		var itemBelow = matrix[cell.row + 1] &amp;&amp; matrix[cell.row + 1][cell.col];
		if (itemBelow &amp;&amp; itemBelow.size_x === cell.size_x) {
			result = result
				.concat(itemBelow)
				.concat(getItemsBelow(matrix, itemBelow));
		}
		return result;
	};

	var rows = [];
	var matrix = toMatrix(grid);

	$.each(matrix, function(rowIndex, row) {
		var tmpRow = {&quot;type&quot;: &quot;row&quot;, &quot;items&quot;: []};
		var usedColumns = 0;
		$.each(row || [], function(cellIndex, cell) {
			if (!cell || cell.processed) return true;

			// insert column before current if there is free space
			if (cell.col &gt; usedColumns) {
				tmpRow.items.push({&quot;type&quot;: &quot;column&quot;, &quot;size_x&quot;: cell.col - usedColumns});
				usedColumns = cell.col;
			}

			var itemsBelow = getItemsBelow(matrix, cell);
			$.each(itemsBelow, function(k, item) {
				item.processed = true;
			});
			tmpRow.items.push({
				&quot;type&quot;: &quot;column&quot;,
				&quot;items&quot;: [].concat(cell).concat(itemsBelow),
				&quot;size_x&quot;: cell.size_x
			});

			usedColumns = Math.max(usedColumns, cell.col + cell.size_x);
		});
		// insert column at the end of row if there is free space left
		if (totalColumns &gt; usedColumns) {
			tmpRow.items.push({
				&quot;type&quot;: &quot;column&quot;,
				&quot;size_x&quot;: totalColumns - usedColumns
			});
		}
		rows.push(tmpRow);
	});

	var appsObject = $.extend({}, this.apps);

	(function buildDom(items, container, depth) {
		depth = depth || 0;
		$.each(items || [], function(k, item) {
			if (item.app &amp;&amp; appsObject[item.app]) {
				container.append(appsObject[item.app].view.get(&quot;appContainer&quot;));
				delete appsObject[item.app];
			} else if (item.type) {
				var template = self.templates[item.type];
				var element = $(self.substitute({&quot;template&quot;: template}));
				if (item.size_x) element.addClass(self.cssPrefix + &quot;column-&quot; + item.size_x + &quot;-&quot; + totalColumns);
				if (item.items) buildDom(item.items, element, depth + 1);
				container.append(element);
			}
		});
		if (!depth &amp;&amp; !$.isEmptyObject(appsObject)) {
			// Put all apps from the canvas that were not mentioned in layout to the very end of container.
			// Useful for backwards complatibility and apps added to canvas through API call.
			$.each(appsObject, function(k, app) {
				container.append(app.view.get(&quot;appContainer&quot;));
			});
		}
	})(rows, container);
	return container;
};

canvas.methods._destroyApp = function(app) {
	if (app &amp;&amp; app.instance &amp;&amp; $.isFunction(app.instance.destroy)) app.instance.destroy();
	return (delete this.apps[app.data.id]);
};

canvas.methods._isManuallyConfigured = function() {
	return !$.isEmptyObject(this.get(&quot;data&quot;));
};

canvas.methods._getAppScriptURL = function(config) {
	if (!config.scripts) return config.script;
	var isSecure, script = {
		&quot;dev&quot;: config.scripts.dev || config.scripts.prod,
		&quot;prod&quot;: config.scripts.prod || config.scripts.dev
	}[Echo.Loader.isDebug() ? &quot;dev&quot; : &quot;prod&quot;];
	if (typeof script === &quot;string&quot;) return script;
	isSecure = /^https/.test(window.location.protocol);
	return script[isSecure ? &quot;secure&quot; : &quot;regular&quot;];
};

canvas.methods._loadAppResources = function(apps) {
	var self = this;
	var resources = [];
	var isManual = this._isManuallyConfigured();
	var deferred = $.Deferred();
	$.map(apps, function(app) {
		var script = self._getAppScriptURL(app);
		if (!app.component || !script || !(isManual || app.id)) {
			self._error({
				&quot;args&quot;: {&quot;app&quot;: app},
				&quot;code&quot;: &quot;incomplete_app_config&quot;
			});
			return;
		}
		resources.push({
			&quot;url&quot;: script,
			&quot;loaded&quot;: function() {
				return Echo.Control.isDefined(app.component);
			}
		});
	});
	Echo.Loader.download(resources, function() { deferred.resolve(apps); });
	return deferred.promise();
};

canvas.methods._getOverrides = function(target, spec) {
	return Echo.Utils.foldl({}, spec || [], function(item, acc) {
		// We should convert spec item to lower case because of jQuery
		// HTML5 data attributes implementation http://api.jquery.com/data/#data-html5
		// Since we have config keys in camel case representation like &quot;useSecureAPI&quot;,
		// we should follow to these rules.
		var key = &quot;canvas-&quot; + item.toLowerCase();
		var value = target.data(key);
		if (typeof value !== &quot;undefined&quot;) {
			acc[item] = value;
		}
	});
};

canvas.methods._error = function(args) {
	args.message = args.message || this.labels.get(&quot;error_&quot; + args.code);

<span id='Echo-Canvas-echo_event-onError'>	/**
</span>	 * @echo_event Echo.Canvas.onError
	 * Event which is triggered in case of errors such as invalid configuration,
	 * problems fetching the data from the server side, etc.
	 *
	 * @param {String} topic
	 * Name of the event produced.
	 *
	 * @param {Object} data
	 * Object which contains debug information regarding the error.
	 */
	Echo.Events.publish({
		&quot;topic&quot;: &quot;Echo.Canvas.onError&quot;,
		&quot;data&quot;: args
	});

	Echo.Utils.log($.extend(args, {&quot;type&quot;: &quot;error&quot;, &quot;component&quot;: &quot;Echo.Canvas&quot;}));
	if (args.renderError) {
		this.showMessage({
			&quot;type&quot;: &quot;error&quot;,
			&quot;message&quot;: args.message
		});
	}
};

canvas.methods._getIds = function() {
	var id = this.config.get(&quot;id&quot;);
	var parts = id.split(&quot;#&quot;);
	var normalize = function(s) { return s.replace(/[^a-z\d]/ig, &quot;-&quot;); };
	return {
		&quot;unique&quot;: id,
		&quot;main&quot;: parts[0],
		&quot;normalized&quot;: {
			&quot;unique&quot;: normalize(id),
			&quot;main&quot;: normalize(parts[0])
		}
	};
};

canvas.methods._fetchConfig = function(callback) {
	var self = this, target = this.config.get(&quot;target&quot;);
	var isManual = this._isManuallyConfigured();
	// no need to perform server side request in case
	// we already have all the data on the client side
	if (isManual) {
		callback.call(this);
		return;
	}
	var mode = this.config.get(&quot;mode&quot;);
	var provider = this.config.get(&quot;provider&quot;);
	var isProviderFastly = provider === &quot;fastly&quot;;
	var getConfig = function() {
		return Echo.Loader.canvasesConfigById[self._getIds().unique];
	};
	var parts = Echo.Utils.parseURL(Echo.Loader.config.storageURL[provider][mode]);
	var URL = this.substitute({
		&quot;template&quot;: &quot;{data:scheme}://{data:domain}{data:path}{data:endpoint}&quot;,
		&quot;data&quot;: $.extend(parts, {
			// taking care of the Canvas unique identifier on the page,
			// specified as &quot;#XXX&quot; in the Canvas ID. We don&#39;t need to send this
			// unique page identifier, we send only the primary Canvas ID.
			&quot;endpoint&quot;: this._getIds().main,
			&quot;scheme&quot;: this.config.get(&quot;useSecureAPI&quot;) ? &quot;https&quot; : parts.scheme || &quot;http&quot;
		})
	}) + (isProviderFastly ? &quot;.json&quot; : &quot;&quot;);

	// We rely on asynchronous behavior of the $.ajax method call
	// to implement store/fetch mechanics. But it can occasionally
	// be synchronous while fetching cached response. In order to
	// avoid this issue, we always make $.ajax call asynchronously.
	setTimeout(function() {
		Echo.Utils.retry(function() {
			return $.ajax({
				&quot;url&quot;: URL,
				&quot;crossDomain&quot;: true,
				&quot;cache&quot;: mode !== &quot;dev&quot;,
				&quot;dataType&quot;: isProviderFastly ? &quot;json&quot; : &quot;script&quot;,
				&quot;timeout&quot;: Echo.Loader.config.errorTimeout,
				&quot;success&quot;: function() {
					var config = isProviderFastly ? arguments[0] : getConfig();
					if (!config || !config.apps || !config.apps.length) {
						var message = self.labels.get(&quot;error_no_&quot; + (config ? &quot;apps&quot; : &quot;config&quot;));
						// clean up the target element to hide &quot;Loading...&quot; message
						self.config.get(&quot;target&quot;).empty();
						self._error({
							&quot;args&quot;: {&quot;config&quot;: config, &quot;target&quot;: target},
							&quot;code&quot;: &quot;invalid_canvas_config&quot;,
							&quot;message&quot;: message
						});
						return;
					}
					self.set(&quot;data&quot;, config); // store Canvas data into the instance
					callback.call(self);
				}
			});
		}, {&quot;ratio&quot;: 1, &quot;times&quot;: self.config.get(&quot;maxConfigFetchingRetries&quot;)})
		.fail(function() {
			self._error({
				&quot;args&quot;: {&quot;target&quot;: self.config.get(&quot;target&quot;), &quot;network&quot;: arguments},
				&quot;code&quot;: &quot;unable_to_retrieve_app_config&quot;,
				&quot;renderError&quot;: true
			});
		});
	}, 0);
};

var columnWidth = [];
for (var totalColumns = 1; totalColumns &lt;= 8; totalColumns++) {
	for (var columnSize = 1; columnSize &lt;= totalColumns; columnSize++ ) {
		columnWidth.push(&#39;.{class:column-&#39; + columnSize + &#39;-&#39; + totalColumns + &#39;} { width: &#39; + columnSize/totalColumns*100 + &#39;%; }&#39;);
	}
}

canvas.css =
	&#39;.{class:appHeader} { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }&#39; +
	&#39;@media (min-width: 400px) {&#39; +
		&#39;.{class:row} { display: table; table-layout: fixed; width: 100%; }&#39; +
		&#39;.{class:column} { display: table-cell; vertical-align: top; }&#39; +
		columnWidth.join(&quot; &quot;) +
	&#39;}&#39;;

Echo.Control.create(canvas);

})(Echo.jQuery);
</pre>
</body>
</html>
