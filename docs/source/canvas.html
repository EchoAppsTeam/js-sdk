<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(jQuery) {
&quot;use strict&quot;;

var $ = jQuery;

var canvas = Echo.Control.manifest(&quot;Echo.Canvas&quot;);

if (Echo.Control.isDefined(canvas)) return;

<span id='Echo-Canvas-method-constructor'><span id='Echo-Canvas'>/**
</span></span> * @class Echo.Canvas
 * Class which implements Canvas mechanics on the client side.
 * The instance of this class is created for each Canvas found on the page by
 * the Echo.Loader. The instance of the class can also be created manually in
 * case the Canvas data already exists on the page.
 *
 * @package environment.pack.js
 *
 * @extends Echo.Control
 *
 * @constructor
 * Canvas object constructor to initialize the Echo.Canvas instance
 *
 * @param {Object} config
 * Configuration options
 */

<span id='Echo-Canvas-method-getRelativeTime'>/** @hide @method getRelativeTime */
</span><span id='Echo-Canvas-echo_label-justNow'>/** @hide @echo_label justNow */
</span><span id='Echo-Canvas-echo_label-today'>/** @hide @echo_label today */
</span><span id='Echo-Canvas-echo_label-yesterday'>/** @hide @echo_label yesterday */
</span><span id='Echo-Canvas-echo_label-lastWeek'>/** @hide @echo_label lastWeek */
</span><span id='Echo-Canvas-echo_label-lastMonth'>/** @hide @echo_label lastMonth */
</span><span id='Echo-Canvas-echo_label-secondAgo'>/** @hide @echo_label secondAgo */
</span><span id='Echo-Canvas-echo_label-secondsAgo'>/** @hide @echo_label secondsAgo */
</span><span id='Echo-Canvas-echo_label-minuteAgo'>/** @hide @echo_label minuteAgo */
</span><span id='Echo-Canvas-echo_label-minutesAgo'>/** @hide @echo_label minutesAgo */
</span><span id='Echo-Canvas-echo_label-hourAgo'>/** @hide @echo_label hourAgo */
</span><span id='Echo-Canvas-echo_label-hoursAgo'>/** @hide @echo_label hoursAgo */
</span><span id='Echo-Canvas-echo_label-dayAgo'>/** @hide @echo_label dayAgo */
</span><span id='Echo-Canvas-echo_label-daysAgo'>/** @hide @echo_label daysAgo */
</span><span id='Echo-Canvas-echo_label-weekAgo'>/** @hide @echo_label weekAgo */
</span><span id='Echo-Canvas-echo_label-weeksAgo'>/** @hide @echo_label weeksAgo */
</span><span id='Echo-Canvas-echo_label-monthAgo'>/** @hide @echo_label monthAgo */
</span><span id='Echo-Canvas-echo_label-monthsAgo'>/** @hide @echo_label monthsAgo */
</span><span id='Echo-Canvas-echo_label-loading'>/** @hide @echo_label loading */
</span><span id='Echo-Canvas-echo_label-retrying'>/** @hide @echo_label retrying */
</span><span id='Echo-Canvas-echo_label-error_busy'>/** @hide @echo_label error_busy */
</span><span id='Echo-Canvas-echo_label-error_timeout'>/** @hide @echo_label error_timeout */
</span><span id='Echo-Canvas-echo_label-error_waiting'>/** @hide @echo_label error_waiting */
</span><span id='Echo-Canvas-echo_label-error_view_limit'>/** @hide @echo_label error_view_limit */
</span><span id='Echo-Canvas-echo_label-error_view_update_capacity_exceeded'>/** @hide @echo_label error_view_update_capacity_exceeded */
</span><span id='Echo-Canvas-echo_label-error_result_too_large'>/** @hide @echo_label error_result_too_large */
</span><span id='Echo-Canvas-echo_label-error_wrong_query'>/** @hide @echo_label error_wrong_query */
</span><span id='Echo-Canvas-echo_label-error_incorrect_appkey'>/** @hide @echo_label error_incorrect_appkey */
</span><span id='Echo-Canvas-echo_label-error_internal_error'>/** @hide @echo_label error_internal_error */
</span><span id='Echo-Canvas-echo_label-error_quota_exceeded'>/** @hide @echo_label error_quota_exceeded */
</span><span id='Echo-Canvas-echo_label-error_incorrect_user_id'>/** @hide @echo_label error_incorrect_user_id */
</span><span id='Echo-Canvas-echo_label-error_unknown'>/** @hide @echo_label error_unknown */
</span>
<span id='Echo-Canvas-echo_event-onReady'>/**
</span> * @echo_event Echo.Canvas.onReady
 * Triggered when the app initialization is finished completely.
 */
<span id='Echo-Canvas-echo_event-onRefresh'>/**
</span> * @echo_event Echo.Canvas.onRefresh
 * Triggered when the app is refreshed. For example after the user
 * login/logout action or as a result of the &quot;refresh&quot; function call.
 */
<span id='Echo-Canvas-echo_event-onRender'>/**
</span> * @echo_event Echo.Canvas.onRender
 * Triggered when the app is rendered.
 */
<span id='Echo-Canvas-echo_event-onRerender'>/**
</span> * @echo_event Echo.Canvas.onRerender
 * Triggered when the app is rerendered.
 */

canvas.init = function() {
	var ids, cssClass;
	var self = this, target = this.config.get(&quot;target&quot;);
	// parent init function takes care about init finalization (rendering
	// and the &quot;onReady&quot; event firing)
	var parent = $.proxy(this.parent, this);

	// check if the canvas was already initialized
	if (target.data(&quot;echo-canvas-initialized&quot;)) {
		this._error({
			&quot;args&quot;: {&quot;target&quot;: target},
			&quot;code&quot;: &quot;canvas_already_initialized&quot;
		});
		return;
	}

	// define initialized state for the canvas
	// to prevent multiple initialization of the same canvas
	target.data(&quot;echo-canvas-initialized&quot;, true);

	// extending Canvas config with the parameters defined in the target
	var overrides = this._getOverrides(target, [&quot;id&quot;, &quot;useSecureAPI&quot;, &quot;mode&quot;, &quot;provider&quot;, &quot;maxConfigFetchingRetries&quot;]);
	if (!$.isEmptyObject(overrides)) {
		this.config.extend(overrides);
	}

	if (Echo.Loader.isDebug()) this.config.set(&quot;mode&quot;, &quot;dev&quot;);

	// exit if no &quot;id&quot; is defined for the canvas,
	// skip this validation in case the &quot;data&quot; is defined explicitly in the config
	if (!this._isManuallyConfigured() &amp;&amp; !this.config.get(&quot;id&quot;)) {
		this._error({
			&quot;args&quot;: {&quot;target&quot;: target},
			&quot;code&quot;: &quot;invalid_canvas_config&quot;
		});
		return;
	}

	// apply our canvas id as a CSS class if we aren&#39;t manually configured
	if (this.config.get(&quot;id&quot;)) {
		ids = this._getIds().normalized;
		// adding a primary canvas ID and unique page identifier
		// as a CSS class if provided
		cssClass = Echo.Utils.foldl(&quot;&quot;, [&quot;main&quot;, &quot;unique&quot;], function(type, acc) {
			return (acc += ids[type] ? self.get(&quot;cssPrefix&quot;) + ids[type] + &quot; &quot; : &quot;&quot;);
		});
		target.addClass(cssClass);
	}

	// fetch canvas config from remote storage
	this._fetchConfig(function() {
		var backplane = self.get(&quot;data.backplane&quot;);
		if (backplane) {
			Backplane.init(backplane);
		}
		self._loadAppResources(parent);
	});
};

canvas.config = {
<span id='Echo-Canvas-cfg-id'>	/**
</span>	 * @cfg {String} [id]
	 * Unique ID of the Canvas, used by the Echo.Canvas instance
	 * to retrieve the data from the Canvases data storage.
	 */
	&quot;id&quot;: &quot;&quot;,

<span id='Echo-Canvas-cfg-data'>	/**
</span>	 * @cfg {Object} [data]
	 * Object which contains the Canvas data in the format
	 * used to store the Canvas config in the Canvas storage.
	 */
	&quot;data&quot;: {},

<span id='Echo-Canvas-cfg-target'>	/**
</span>	 * @cfg {String} target(required)
	 * Specifies the DOM element where the control will be displayed.
	 *
	 * Note: if only the &quot;target&quot; config parameter is defined, the target DOM element
	 * should contain the following HTML attribute:
	 *
	 * + &quot;data-canvas-id&quot; with the unique Canvas ID which should be initialized
	 *
	 * The values of the HTML parameters override the &quot;id&quot; parameter value
	 * (respectively) passed via the Canvas config.
	 */

<span id='Echo-Canvas-cfg-overrides'>	/**
</span>	 * @cfg {Object} [overrides]
	 * Object which contains the overrides applied for this Canvas on the page
	 * via Echo.Loader.override function call.
	 */
	&quot;overrides&quot;: {},

<span id='Echo-Canvas-cfg-mode'>	/**
</span>	 * @cfg {String} [mode]
	 * This parameter specifies the mode in which Canvas works.
	 * There are two possible values for this parameter:
	 *
	 * + &quot;dev&quot; - in this case the Canvas works with the development configuration storage
	 * + &quot;prod&quot; - in this case the Canvas works with the production configuration storage
	 *
	 * More information about defference between production and development configuration
	 * storages can be found in the [&quot;How to deploy an App using a Canvas guide&quot;](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 *
	 * The value of this parameter can be overridden by specifying the &quot;data-canvas-mode&quot;
	 * target DOM element attribute.
	 * More information about HTML attributes of the target DOM element can be found [here](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 */
	&quot;mode&quot;: &quot;prod&quot;,

<span id='Echo-Canvas-cfg-maxConfigFetchingRetries'>	/**
</span>	 * @cfg {Number} [maxConfigFetchingRetries]
	 * The number of retries attempts to fetch canvas config.
	 *
	 * The value of this parameter can be overridden by specifying the &quot;data-canvas-maxConfigFetchingRetries&quot;
	 * target DOM element attribute.
	 * More information about HTML attributes of the target DOM element can be found [here](#!/guide/how_to_deploy_an_app_using_a_canvas)
	 */
	&quot;maxConfigFetchingRetries&quot;: 2,

	&quot;provider&quot;: &quot;aws&quot;, // &quot;aws&quot; | &quot;fastly&quot;

<span id='Echo-Canvas-cfg-refreshOnUserInvalidate'>	/**
</span>	 * @cfg {Boolean} refreshOnUserInvalidate=false
	 * @inheritdoc
	 */
	&quot;refreshOnUserInvalidate&quot;: false
};

canvas.vars = {
	&quot;apps&quot;: []
};

canvas.labels = {
<span id='Echo-Canvas-echo_label-error_no_apps'>	/**
</span>	 * @echo_label
	 */
	&quot;error_no_apps&quot;: &quot;No applications defined for this canvas&quot;,
<span id='Echo-Canvas-echo_label-error_no_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_no_config&quot;: &quot;Unable to retrieve Canvas config&quot;,
<span id='Echo-Canvas-echo_label-error_no_suitable_app_class'>	/**
</span>	 * @echo_label
	 */
	&quot;error_no_suitable_app_class&quot;: &quot;Unable to init an app, no suitable JS class found&quot;,
<span id='Echo-Canvas-echo_label-error_unable_to_retrieve_app_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_unable_to_retrieve_app_config&quot;: &quot;Unable to retrieve Canvas config from the storage&quot;,
<span id='Echo-Canvas-echo_label-error_incomplete_app_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_incomplete_app_config&quot;: &quot;Unable to init an app, config is incomplete&quot;,
<span id='Echo-Canvas-echo_label-error_canvas_already_initialized'>	/**
</span>	 * @echo_label
	 */
	&quot;error_canvas_already_initialized&quot;: &quot;Canvas has been initialized already&quot;,
<span id='Echo-Canvas-echo_label-error_invalid_canvas_config'>	/**
</span>	 * @echo_label
	 */
	&quot;error_invalid_canvas_config&quot;: &quot;Canvas with invalid configuration found&quot;
};

<span id='Echo-Canvas-echo_template-main'>/**
</span> * @echo_template
 */
canvas.templates.main =
	&#39;&lt;div class=&quot;{class:container}&quot;&gt;&lt;/div&gt;&#39;;

<span id='Echo-Canvas-echo_template-app'>/**
</span> * @echo_template
 */
canvas.templates.app =
	&#39;&lt;div class=&quot;{class:appContainer}&quot;&gt;&#39; +
		&#39;&lt;div class=&quot;{class:appHeader}&quot;&gt;{data:caption}&lt;/div&gt;&#39; +
		&#39;&lt;div class=&quot;{class:appBody}&quot;&gt;&lt;/div&gt;&#39; +
	&#39;&lt;/div&gt;&#39;;

canvas.destroy = function() {
	$.map(this.get(&quot;apps&quot;), $.proxy(this._destroyApp, this));
	this.config.get(&quot;target&quot;).data(&quot;echo-canvas-initialized&quot;, false);
	// remove cached canvas config
	Echo.Utils.remove(Echo.Loader.canvasesConfigById, this._getIds().unique);
};

<span id='Echo-Canvas-echo_renderer-container'>/**
</span> * @echo_renderer
 */
canvas.renderers.container = function(element) {
	var self = this;
	$.map(this.get(&quot;data.apps&quot;), function(app, id) {
		self._initApp(app, element, id);
	});
	return element;
};

canvas.methods._initApp = function(app, element, id) {
	var self = this;
	var Application = Echo.Utils.getComponent(app.component);
	if (!Application) {
		this._error({
			&quot;args&quot;: {&quot;app&quot;: app},
			&quot;code&quot;: &quot;no_suitable_app_class&quot;
		});
		return;
	}

	app.id = app.id || id;  // define app position in array as id if not specified
	app.config = app.config || {};
	app.config.canvasId = this.config.get(&#39;id&#39;);

	var view = this.view.fork({
		&quot;renderer&quot;: null,
		&quot;renderers&quot;: {
			&quot;appHeader&quot;: function(element) {
				// show|hide app header depending on the caption existance
				return element[app.caption ? &quot;show&quot; : &quot;hide&quot;]();
			},
			&quot;appBody&quot;: function(element) {
				var className = self.get(&quot;cssPrefix&quot;) + &quot;appId-&quot; + app.id;
				return element.addClass(className);
			}
		}
	});
	element.append(view.render({
		&quot;data&quot;: app,
		&quot;template&quot;: this.templates.app
	}));

	app.config.target = view.get(&quot;appBody&quot;);

	var overrides = this.config.get(&quot;overrides&quot;)[app.id];
	var config = overrides
		? $.extend(true, app.config, overrides)
		: app.config;
	this.apps.push(new Application(config));
};

canvas.methods._destroyApp = function(app) {
	if (app &amp;&amp; $.isFunction(app.destroy)) app.destroy();
};

canvas.methods._isManuallyConfigured = function() {
	return !$.isEmptyObject(this.get(&quot;data&quot;));
};

canvas.methods._getAppScriptURL = function(config) {
	if (!config.scripts) return config.script;
	var isSecure, script = {
		&quot;dev&quot;: config.scripts.dev || config.scripts.prod,
		&quot;prod&quot;: config.scripts.prod || config.scripts.dev
	}[Echo.Loader.isDebug() ? &quot;dev&quot; : &quot;prod&quot;];
	if (typeof script === &quot;string&quot;) return script;
	isSecure = /^https/.test(window.location.protocol);
	return script[isSecure ? &quot;secure&quot; : &quot;regular&quot;];
};

canvas.methods._loadAppResources = function(callback) {
	var self = this, resources = [], isManual = this._isManuallyConfigured();
	$.map(this.get(&quot;data.apps&quot;), function(app) {
		var script = self._getAppScriptURL(app);
		if (!app.component || !script || !(isManual || app.id)) {
			self._error({
				&quot;args&quot;: {&quot;app&quot;: app},
				&quot;code&quot;: &quot;incomplete_app_config&quot;
			});
			return;
		}
		resources.push({
			&quot;url&quot;: script,
			&quot;loaded&quot;: function() {
				return Echo.Control.isDefined(app.component);
			}
		});
	});
	Echo.Loader.download(resources, callback);
};

canvas.methods._getOverrides = function(target, spec) {
	return Echo.Utils.foldl({}, spec || [], function(item, acc) {
		// We should convert spec item to lower case because of jQuery
		// HTML5 data attributes implementation http://api.jquery.com/data/#data-html5
		// Since we have config keys in camel case representation like &quot;useSecureAPI&quot;,
		// we should follow to these rules.
		var key = &quot;canvas-&quot; + item.toLowerCase();
		var value = target.data(key);
		if (typeof value !== &quot;undefined&quot;) {
			acc[item] = value;
		}
	});
};

canvas.methods._error = function(args) {
	args.message = args.message || this.labels.get(&quot;error_&quot; + args.code);

<span id='Echo-Canvas-echo_event-onError'>	/**
</span>	 * @echo_event Echo.Canvas.onError
	 * Event which is triggered in case of errors such as invalid configuration,
	 * problems fetching the data from the server side, etc.
	 *
	 * @param {String} topic
	 * Name of the event produced.
	 *
	 * @param {Object} data
	 * Object which contains debug information regarding the error.
	 */
	Echo.Events.publish({
		&quot;topic&quot;: &quot;Echo.Canvas.onError&quot;,
		&quot;data&quot;: args
	});

	Echo.Utils.log($.extend(args, {&quot;type&quot;: &quot;error&quot;, &quot;component&quot;: &quot;Echo.Canvas&quot;}));
	if (args.renderError) {
		this.showMessage({
			&quot;type&quot;: &quot;error&quot;,
			&quot;message&quot;: args.message
		});
	}
};

canvas.methods._getIds = function() {
	var id = this.config.get(&quot;id&quot;);
	var parts = id.split(&quot;#&quot;);
	var normalize = function(s) { return s.replace(/[^a-z\d]/ig, &quot;-&quot;); };
	return {
		&quot;unique&quot;: id,
		&quot;main&quot;: parts[0],
		&quot;normalized&quot;: {
			&quot;unique&quot;: normalize(id),
			&quot;main&quot;: normalize(parts[0])
		}
	};
};

canvas.methods._fetchConfig = function(callback) {
	var self = this, target = this.config.get(&quot;target&quot;);
	var isManual = this._isManuallyConfigured();
	// no need to perform server side request in case
	// we already have all the data on the client side
	if (isManual) {
		callback.call(this);
		return;
	}
	var mode = this.config.get(&quot;mode&quot;);
	var provider = this.config.get(&quot;provider&quot;);
	var isProviderFastly = provider === &quot;fastly&quot;;
	var getConfig = function() {
		return Echo.Loader.canvasesConfigById[self._getIds().unique];
	};
	var parts = Echo.Utils.parseURL(Echo.Loader.config.storageURL[provider][mode]);
	var URL = this.substitute({
		&quot;template&quot;: &quot;{data:scheme}://{data:domain}{data:path}{data:endpoint}&quot;,
		&quot;data&quot;: $.extend(parts, {
			// taking care of the Canvas unique identifier on the page,
			// specified as &quot;#XXX&quot; in the Canvas ID. We don&#39;t need to send this
			// unique page identifier, we send only the primary Canvas ID.
			&quot;endpoint&quot;: this._getIds().main,
			&quot;scheme&quot;: this.config.get(&quot;useSecureAPI&quot;) ? &quot;https&quot; : parts.scheme || &quot;http&quot;
		})
	}) + (isProviderFastly ? &quot;.json&quot; : &quot;&quot;);

	// We rely on asynchronous behavior of the $.ajax method call
	// to implement store/fetch mechanics. But it can occasionally
	// be synchronous while fetching cached response. In order to
	// avoid this issue, we always make $.ajax call asynchronously.
	setTimeout(function() {
		Echo.Utils.retry(function() {
			return $.ajax({
				&quot;url&quot;: URL,
				&quot;crossDomain&quot;: true,
				&quot;cache&quot;: mode !== &quot;dev&quot;,
				&quot;dataType&quot;: isProviderFastly ? &quot;json&quot; : &quot;script&quot;,
				&quot;timeout&quot;: Echo.Loader.config.errorTimeout,
				&quot;success&quot;: function() {
					var config = isProviderFastly ? arguments[0] : getConfig();
					if (!config || !config.apps || !config.apps.length) {
						var message = self.labels.get(&quot;error_no_&quot; + (config ? &quot;apps&quot; : &quot;config&quot;));
						// clean up the target element to hide &quot;Loading...&quot; message
						self.config.get(&quot;target&quot;).empty();
						self._error({
							&quot;args&quot;: {&quot;config&quot;: config, &quot;target&quot;: target},
							&quot;code&quot;: &quot;invalid_canvas_config&quot;,
							&quot;message&quot;: message
						});
						return;
					}
					self.set(&quot;data&quot;, config); // store Canvas data into the instance
					callback.call(self);
				}
			});
		}, {&quot;ratio&quot;: 1, &quot;times&quot;: self.config.get(&quot;maxConfigFetchingRetries&quot;)})
		.fail(function() {
			self._error({
				&quot;args&quot;: {&quot;target&quot;: self.config.get(&quot;target&quot;), &quot;network&quot;: arguments},
				&quot;code&quot;: &quot;unable_to_retrieve_app_config&quot;,
				&quot;renderError&quot;: true
			});
		});
	}, 0);
};

Echo.Control.create(canvas);

})(Echo.jQuery);
</pre>
</body>
</html>
