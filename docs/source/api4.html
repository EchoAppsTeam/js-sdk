<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(jQuery) {
&quot;use strict&quot;;

var $ = jQuery;

if (Echo.API &amp;&amp; Echo.API.Transport) return;

Echo.API = {&quot;Transports&quot;: {}, &quot;Request&quot;: {}};

var utils = Echo.Utils;

Echo.API.Transport = function(config) {
	this.config = new Echo.Configuration(config, {
		&quot;data&quot;: {},
		&quot;uri&quot;: &quot;&quot;,
		&quot;secure&quot;: false,
		&quot;settings&quot;: {
			&quot;crossDomain&quot;: true,
			&quot;dataType&quot;: &quot;json&quot;
		},
		&quot;onData&quot;: function() {},
		&quot;onOpen&quot;: function() {},
		&quot;onClose&quot;: function() {},
		&quot;onError&quot;: function() {}
	});
	this._connect();
};

Echo.API.Transport.prototype._connect = function() {
	this.transportObject = this._getTransportObject();
};

Echo.API.Transport.prototype._wrapErrorResponse = function(responseError) {
	return {
		&quot;result&quot;: &quot;error&quot;,
		&quot;errorCode&quot;: &quot;connection_failure&quot;,
		&quot;errorMessage&quot;: &quot;&quot;,
		&quot;transportError&quot;: responseError || &quot;&quot;
	};
};

Echo.API.Transport.prototype._prepareURL = function() {
	return this._getScheme() + &quot;//&quot; + this.config.get(&quot;uri&quot;);
};

<span id='Echo-API-Transports-WebSockets'>/**
</span> * @ignore
 * @class Echo.API.Transports.WebSockets
 */
Echo.API.Transports.WebSockets = utils.inherit(Echo.API.Transport, function(config) {
	if (!config || !config.uri) {
		Echo.Utils.log({
			&quot;type&quot;: &quot;error&quot;,
			&quot;component&quot;: &quot;Echo.API.Transports.WebSockets&quot;,
			&quot;message&quot;: &quot;Unable to initialize WebSockets transport, config is invalid&quot;,
			&quot;args&quot;: {&quot;config&quot;: config}
		});
		return;
	}
	config = $.extend(true, {
		&quot;settings&quot;: {
			&quot;maxConnectRetries&quot;: 3,
			&quot;serverPingInterval&quot;: 30, // client-server ping-pong interval (in seconds)
			&quot;closeSocketTimeout&quot;: 10, // time (in seconds) we can give WS to close connection
			&quot;protocols&quot;: [&quot;liveupdate.ws.echoenabled.com&quot;]
		}
	}, config || {});
	this.timers = {
		&quot;ping&quot;: null,
		&quot;pong&quot;: null,
		&quot;close&quot;: null
	};
	this.subscriptionIds = {};
	this.unique = Echo.Utils.getUniqueString();
	Echo.API.Transports.WebSockets.parent.constructor.call(this, config);
});

Echo.API.Transports.WebSockets.socketByURI = {};

Echo.API.Transports.WebSockets.prototype.connecting = function() {
	return this.transportObject &amp;&amp; this.transportObject.readyState === 0;
};

Echo.API.Transports.WebSockets.prototype.connected = function() {
	return this.transportObject &amp;&amp; this.transportObject.readyState === 1;
};

Echo.API.Transports.WebSockets.prototype.closing = function() {
	return this.transportObject &amp;&amp; this.transportObject.readyState === 2;
};

Echo.API.Transports.WebSockets.prototype.closed = function() {
	return this.transportObject &amp;&amp; this.transportObject.readyState === 3;
};

Echo.API.Transports.WebSockets.prototype.subscribe = function(topic, params) {
	var id = Echo.Events.subscribe(
		$.extend(true, {
			&quot;topic&quot;: &quot;Echo.API.Transports.WebSockets.&quot; + topic,
			&quot;context&quot;: this._context(this.unique)
		}, params)
	);
	this.subscriptionIds[topic] = this.subscriptionIds[topic] || [];
	this.subscriptionIds[topic].push(id);
	return id;
};

Echo.API.Transports.WebSockets.prototype.unsubscribe = function unsubscribe(arg) {
	var subscriptionIds, self = this;
	if (typeof arg === &quot;string&quot;) {
		subscriptionIds = this.subscriptionIds[arg];
		if (subscriptionIds) {
			$.map(subscriptionIds, function(id) {
				Echo.Events.unsubscribe({&quot;handlerId&quot;: id});
			});
			this.subscriptionIds[arg] = [];
		} else {
			$.each(this.subscriptionIds, function(topic, ids) {
				self.subscriptionIds[topic] = Echo.Utils.foldl([], ids, function(id, acc) {
					if (id.toString() === arg.toString()) {
						Echo.Events.unsubscribe({&quot;handlerId&quot;: id});
					} else {
						acc.push(id);
					}
				});
			});
		}
	} else {
		$.each(this.subscriptionIds, $.proxy(unsubscribe, this));
		this.subscriptionIds = {};
	}
};

Echo.API.Transports.WebSockets.prototype.abort = function(force) {
	var self = this;
	var socket = Echo.API.Transports.WebSockets.socketByURI[this.config.get(&quot;uri&quot;)];
	if (socket) {
		delete socket.subscribers[this.unique];
		this._clearTimers();
		this.subscribe(&quot;onClose&quot;, {
			&quot;once&quot;: true,
			&quot;handler&quot;: function() {
				self.unsubscribe();
			}
		});
		// close socket connection if the last subscriber left
		if (($.isEmptyObject(socket.subscribers) || force) &amp;&amp; this.connected()) {
			// if closing a coonection to WS takes more time than
			// setting &quot;closeSocketTimeout&quot; is - we force switchover to Polling
			this.timers.close = setTimeout(
				$.proxy(this._onCloseHandler, this),
				this.config.get(&quot;settings.closeSocketTimeout&quot;) * 1000
			);
			this.transportObject.close();
		}
	}
};

Echo.API.Transports.WebSockets.prototype.send = function(event) {
	event.subscription = event.subscription || this.unique;
	return this.transportObject.send(Echo.Utils.objectToJSON(event));
};

Echo.API.Transports.WebSockets.prototype.keepConnection = function() {
	// establish periodical client-server ping-pong to keep connection alive
	var interval = this.config.get(&quot;settings.serverPingInterval&quot;) * 1000;
	this.timers.ping = setInterval($.proxy(this._ping, this), interval);
};

Echo.API.Transports.WebSockets.prototype.publish = function(topic, data) {
	this._publish(topic, data, this.unique);
};

// private functions

Echo.API.Transports.WebSockets.prototype._getScheme = function() {
	return this.config.get(&quot;secure&quot;) ? &quot;wss:&quot; : &quot;ws:&quot;;
};

Echo.API.Transports.WebSockets.prototype._context = function(subscriptionId) {
	return this.config.get(&quot;uri&quot;).replace(/\//g, &quot;-&quot;) + (subscriptionId ? &quot;/&quot; + subscriptionId : &quot;&quot;);
};

Echo.API.Transports.WebSockets.prototype._getTransportObject = function() {
	var self = this, uri = this.config.get(&quot;uri&quot;);
	var sockets = Echo.API.Transports.WebSockets.socketByURI;
	$.map([&quot;onOpen&quot;, &quot;onClose&quot;, &quot;onError&quot;, &quot;onData&quot;], function(topic) {
		self.subscribe(topic, {
			&quot;handler&quot;: function(_, data) {
				self.config.get(topic)(data);
				if (topic === &quot;onClose&quot;) {
					clearTimeout(self.timers.close);
				}
			},
			// when we receive data - send it to the appropriate
			// subscribers only (do not send it to all subscribers)
			&quot;context&quot;: self._context(topic === &quot;onData&quot; ? self.unique : undefined)
		});
	});

	if (!sockets[uri]) {
		sockets[uri] = {
			&quot;socket&quot;: this._prepareTransportObject(),
			&quot;subscribers&quot;: {}
		};
	}
	// register socket subscriber
	sockets[uri].subscribers[this.unique] = true;

	return sockets[uri].socket;
};

Echo.API.Transports.WebSockets.prototype._prepareTransportObject = function() {
	var self = this;

	// return in case we are connected or connection is in progress
	if (this.connecting() || this.connected()) return;

	this._clearTimers();

	var socket = new (window.WebSocket || window.MozWebSocket)(this._prepareURL(), this.config.get(&quot;settings.protocols&quot;));
	socket.onopen = function() {
		// send ping immediately to make sure the server is responding
		self._ping(function() {
			self._publish(&quot;onOpen&quot;);
		});
		self.keepConnection();
	};
	socket.onmessage = function(event) {
		if (!event || !event.data) return;
		var data = $.parseJSON(event.data);
		self._publish(&quot;onData&quot;, data, data &amp;&amp; data.subscription);
	};
	socket.onclose = function() {
		self._onCloseHandler();
	};
	socket.onerror = function(error) {
		self._publish(&quot;onError&quot;, self._wrapErrorResponse(error));
	};
	return socket;
};

Echo.API.Transports.WebSockets.prototype._resetRetriesAttempts = function() {
	this.attemptsRemaining = this.config.get(&quot;settings.maxConnectRetries&quot;);
};

Echo.API.Transports.WebSockets.prototype._clearTimers = function() {
	this.timers.ping &amp;&amp; clearInterval(this.timers.ping);
	this.timers.pong &amp;&amp; clearTimeout(this.timers.pong);
	this.timers = {};
};

Echo.API.Transports.WebSockets.prototype._onCloseHandler = function() {
	this._publish(&quot;onClose&quot;);
	this._clear();
};

Echo.API.Transports.WebSockets.prototype._clear = function() {
	var context = this.config.get(&quot;uri&quot;).replace(/\//g, &quot;-&quot;);
	delete Echo.API.Transports.WebSockets.socketByURI[this.config.get(&quot;uri&quot;)];
};

Echo.API.Transports.WebSockets.prototype._publish = function(topic, data, subscriptionId) {
	Echo.Events.publish({
		&quot;topic&quot;: &quot;Echo.API.Transports.WebSockets.&quot; + topic,
		&quot;data&quot;: data || {},
		&quot;propagation&quot;: !subscriptionId,
		&quot;global&quot;: false,
		&quot;context&quot;: this._context(subscriptionId)
	});
};

Echo.API.Transports.WebSockets.prototype._ping = function(callback) {
	var self = this;
	var id = Echo.Events.subscribe({
		&quot;topic&quot;: &quot;Echo.API.Transports.WebSockets.onData&quot;,
		&quot;handler&quot;: function(topic, data) {
			// we are expecting &quot;pong&quot; message only...
			if (!data || data.event !== &quot;pong&quot;) return;

			clearTimeout(self.timers.pong);
			Echo.Events.unsubscribe({&quot;handlerId&quot;: id});
			self._resetRetriesAttempts();

			callback &amp;&amp; callback();
		},
		&quot;context&quot;: this._context()
	});

	this.send({&quot;event&quot;: &quot;ping&quot;});
	this.timers.pong = setTimeout(function() {
		Echo.Events.unsubscribe({&quot;handlerId&quot;: id});
		self._tryReconnect();
	}, this.config.get(&quot;settings.serverPingInterval&quot;) * 1000);
};

Echo.API.Transports.WebSockets.prototype._tryReconnect = function() {
	// if we were disconnected and try to connect again - decrease
	// the retries counter to indicate several fail connection attempts in a row
	this.attemptsRemaining--;

	// exit when the connection attempt is scheduled (to prevent
	// multiple connections) or if no connection attempts left
	if (this.attemptsRemaining === 0) {
		this.abort(true);
	}
};

Echo.API.Transports.WebSockets.available = function() {
	return !!(window.WebSocket || window.MozWebSocket);
};

<span id='Echo-API-Transports-AJAX'>/**
</span> * @ignore
 * @class Echo.API.Transports.AJAX
 */
Echo.API.Transports.AJAX = utils.inherit(Echo.API.Transport, function(config) {
	config = $.extend({
		&quot;method&quot;: &quot;get&quot;
	}, config || {});
	return Echo.API.Transports.AJAX.parent.constructor.call(this, config);
});

Echo.API.Transports.AJAX.prototype._getScheme = function() {
	return this.config.get(&quot;secure&quot;) ? &quot;https:&quot; : &quot;http:&quot;;
};

Echo.API.Transports.AJAX.prototype._getTransportObject = function() {
	var self = this;
	return $.extend(true, {
		&quot;url&quot;: this._prepareURL(),
		&quot;type&quot;: this.config.get(&quot;method&quot;),
		&quot;error&quot;: function(errorResponse, requestParams) {
			errorResponse = self._wrapErrorResponse(errorResponse);
			if (errorResponse.transportError &amp;&amp; errorResponse.transportError.statusText === &quot;abort&quot;) {
				errorResponse.errorCode = &quot;connection_aborted&quot;;
			}
			self.config.get(&quot;onError&quot;)(errorResponse, requestParams);
		},
		&quot;success&quot;: this.config.get(&quot;onData&quot;),
		&quot;complete&quot;: this.config.get(&quot;onClose&quot;),
		&quot;beforeSend&quot;: function(jqXHR) {
			self.transportObject = jqXHR;
			self.config.get(&quot;onOpen&quot;).apply(null, arguments);
		}
	}, this.config.get(&quot;settings&quot;));
};

Echo.API.Transports.AJAX.prototype._wrapErrorResponse = function(responseError) {
	var originalWrapped = Echo.API.Transports.AJAX.parent._wrapErrorResponse.apply(this, arguments);
	if (responseError &amp;&amp; responseError.responseText) {
		var errorObject;
		try {
			errorObject = $.parseJSON(responseError.responseText);
		} catch(e) {}
		return errorObject || originalWrapped;
	}
	return originalWrapped;
};

Echo.API.Transports.AJAX.prototype.send = function(data) {
	var configData = this.config.get(&quot;data&quot;);
	data = typeof data === &quot;string&quot;
		? data
		: typeof configData === &quot;string&quot;
			? configData
			: $.extend({}, configData, data || {});
	if (typeof this.transportObject.status === &quot;undefined&quot;) {
		this.transportObject = this._getTransportObject();
		this.transportObject.data = data;
		this.transportObject = $.ajax(this.transportObject);
	} else {
		$.ajax(
			$.extend(this._getTransportObject(), {
				&quot;data&quot;: data
			})
		);
	}
};

Echo.API.Transports.AJAX.prototype.abort = function() {
	// check that transport object initialized by $.ajax function
	// instead of initializing by constructor
	if (this.transportObject &amp;&amp; this.transportObject.abort) {
		this.transportObject.abort();
	}
};

Echo.API.Transports.AJAX.available = function() {
	return $.support.cors;
};

<span id='Echo-API-Transports-XDomainRequest'>/**
</span> * @ignore
 * @class Echo.API.Transports.XDomainRequest
 */
Echo.API.Transports.XDomainRequest = utils.inherit(Echo.API.Transports.AJAX, function() {
	return Echo.API.Transports.XDomainRequest.parent.constructor.apply(this, arguments);
});

Echo.API.Transports.XDomainRequest.prototype._getTransportObject = function() {
	var obj = Echo.API.Transports.XDomainRequest.parent._getTransportObject.call(this);
	var domain = utils.parseURL(document.location.href).domain;
	var targetDomain = utils.parseURL(this.config.get(&quot;uri&quot;)).domain;
	if (domain === targetDomain) {
		return obj;
	}
	// jQuery.XDomainRequest.js
	// Author: Jason Moon - @JSONMOON
	// IE8+
	// link: https://github.com/MoonScript/jQuery-ajaxTransport-XDomainRequest
	if (!jQuery.support.cors &amp;&amp; window.XDomainRequest) {
		var jsonRegEx = /\/json/i;
		var xmlRegEx = /\/xml/i;

		// ajaxTransport exists in jQuery 1.5+
		jQuery.ajaxTransport(&quot;text html xml json&quot;, function(options, userOptions, jqXHR) {
			var xdr = null;
			var userType = (userOptions.dataType || &quot;&quot;).toLowerCase();
			return {
				&quot;send&quot;: function(headers, complete) {
					xdr = new XDomainRequest();
					if (/^\d+$/.test(userOptions.timeout)) {
						xdr.timeout = userOptions.timeout;
					}
					xdr.ontimeout = function() {
						complete(500, &quot;timeout&quot;);
					};
					xdr.onload = function() {
						var allResponseHeaders = &quot;Content-Length: &quot; + xdr.responseText.length + &quot;\r\nContent-Type: &quot; + xdr.contentType;
						var status = {
							&quot;code&quot;: 200,
							&quot;message&quot;: &quot;success&quot;
						};
						var responses = {
							&quot;text&quot;: xdr.responseText
						};
						try {
							if ((userType === &quot;json&quot;) || ((userType !== &quot;text&quot;) &amp;&amp; jsonRegEx.test(xdr.contentType))) {
								try {
									responses.json = $.parseJSON(xdr.responseText);
								} catch(e) {
									status.code = 500;
									status.message = &quot;parseerror&quot;;
								}
							} else if ((userType === &quot;xml&quot;) || ((userType !== &quot;text&quot;) &amp;&amp; xmlRegEx.test(xdr.contentType))) {
								var doc = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);
								doc.async = false;
								try {
									doc.loadXML(xdr.responseText);
								} catch(e) {
									doc = undefined;
								}
								if (!doc || !doc.documentElement || doc.getElementsByTagName(&quot;parsererror&quot;).length) {
									status.code = 500;
									status.message = &quot;parseerror&quot;;
									throw &quot;Invalid XML: &quot; + xdr.responseText;
								}
								responses.xml = doc;
							}
						} catch(parseMessage) {
							throw parseMessage;
						} finally {
							complete(status.code, status.message, responses, allResponseHeaders);
						}
					};
					xdr.onerror = function() {
						complete(500, &quot;error&quot;, {
							&quot;text&quot;: xdr.responseText
						});
					};
					var postData = typeof userOptions.data === &quot;string&quot;
						? userOptions.data
						: $.param(userOptions.data || &quot;&quot;);
					xdr.open(options.type, options.url);
					xdr.send(postData);
				},
				&quot;abort&quot;: function() {
					if (xdr) {
						xdr.abort();
					}
				}
			};
		});
	}
	// avoid caching the respond result
	return $.extend(obj, {
		&quot;cache&quot;: false
	});
};

Echo.API.Transports.XDomainRequest.available = function(config) {
	config = config || {&quot;method&quot;: &quot;&quot;, &quot;secure&quot;: false};
	var scheme = config.secure ? &quot;https:&quot; : &quot;http:&quot;;
	// XDomainRequests must be: GET or POST methods, HTTP or HTTPS protocol,
	// and same scheme as calling page
	var transportSpecAvailability = /^get|post$/i.test(config.method)
		&amp;&amp; /^https?/.test(scheme)
		&amp;&amp; document.location.protocol === scheme;
	return &quot;XDomainRequest&quot; in window
		&amp;&amp; transportSpecAvailability;
};

<span id='Echo-API-Transports-JSONP'>/**
</span> * @ignore
 * @class Echo.API.Transports.JSONP
 */
Echo.API.Transports.JSONP = utils.inherit(Echo.API.Transports.AJAX, function(config) {
	return Echo.API.Transports.JSONP.parent.constructor.apply(this, arguments);
});

Echo.API.Transports.JSONP.prototype.send = function(data) {
	if (this.config.get(&quot;method&quot;).toLowerCase() === &quot;get&quot;) {
		return Echo.API.Transports.JSONP.parent.send.apply(this, arguments);
	}
	this._pushPostParameters($.extend({}, this.config.get(&quot;data&quot;), data));
	this.transportObject.form.submit();
	this.config.get(&quot;onData&quot;)();
};

Echo.API.Transports.JSONP.prototype.abort = function() {
	if (this.transportObject.form &amp;&amp; this.transportObject.iframe) {
		this.transportObject.form.remove();
		this.transportObject.iframe.remove();
		return;
	}
	return Echo.API.Transports.JSONP.parent.abort.call(this);
};

Echo.API.Transports.JSONP.prototype._getTransportObject = function() {
	var settings = Echo.API.Transports.JSONP.parent._getTransportObject.call(this);
	if (this.config.get(&quot;method&quot;).toLowerCase() === &quot;post&quot;) {
		return this._getPostTransportObject({
			&quot;url&quot;: settings.url
		});
	}
	delete settings.xhr;
	settings.dataType = &quot;jsonp&quot;;
	return settings;
};

Echo.API.Transports.JSONP.prototype._getPostTransportObject = function(settings) {
	var id = &quot;echo-post-&quot; + Math.random();
	var container =
		$(&quot;#echo-post-request&quot;).length
			? $(&quot;#echo-post-request&quot;).empty()
			: $(&#39;&lt;div id=&quot;echo-post-request&quot;/&gt;&#39;).css({&quot;height&quot;: 0}).prependTo(&quot;body&quot;);
	// it won&#39;t work if the attributes are specified as a hash in the second parameter
	this.iframe = this.iframe || $(&#39;&lt;iframe id=&quot;&#39; + id + &#39;&quot; name=&quot;&#39; + id + &#39;&quot; width=&quot;0&quot; height=&quot;0&quot; frameborder=&quot;0&quot; border=&quot;0&quot;&gt;&lt;/iframe&gt;&#39;).appendTo(container);
	var form = $(&quot;&lt;form/&gt;&quot;, {
		&quot;target&quot; : id,
		&quot;method&quot; : &quot;POST&quot;,
		&quot;enctype&quot; : &quot;application/x-www-form-urlencoded&quot;,
		&quot;acceptCharset&quot; : &quot;UTF-8&quot;,
		&quot;action&quot; : settings.url
	}).appendTo(container);
	this._pushPostParameters(settings.data);
	return {
		&quot;form&quot;: form,
		&quot;iframe&quot;: this.iframe
	};
};

Echo.API.Transports.JSONP.prototype._pushPostParameters = function(data) {
	var self = this;
	$.each(data || {}, function(key, value) {
		$(&quot;&lt;input/&gt;&quot;, {
			&quot;type&quot; : &quot;hidden&quot;,
			&quot;name&quot; : key,
			&quot;value&quot; : value
		}).appendTo(self.transportObject.form);
	});
	return self.transportObject;
};

Echo.API.Transports.JSONP.available = function() {
	return true;
};

<span id='Echo-API-Request'>/**
</span> * @class Echo.API.Request
 * Class implementing API requests logic on the transport layer.
 *
 * @package api.pack.js
 * @package environment.pack.js
 */
/*
 * @constructor
 * @param {Object} config
 * Configuration data.
 */
Echo.API.Request = function(config) {
	var self = this;
<span id='Echo-API-Request-cfg-endpoint'>	/**
</span>	 * @cfg {String} endpoint
	 * Specifes the API endpoint.
	 */
	if (!config || !config.endpoint) {
		Echo.Utils.log({
			&quot;type&quot;: &quot;error&quot;,
			&quot;component&quot;: &quot;Echo.API&quot;,
			&quot;message&quot;: &quot;Unable to initialize API request, config is invalid&quot;,
			&quot;args&quot;: {&quot;config&quot;: config}
		});
		return {};
	}

	this.config = new Echo.Configuration(config, {
<span id='Echo-API-Request-cfg-onData'>		/**
</span>		 * @cfg {Function} [onData]
		 * Callback called after API request succeded.
		 */
<span id='Echo-API-Request-cfg-onError'>		/**
</span>		 * @cfg {Function} [onError]
		 * Callback called after API request failed.
		 */
<span id='Echo-API-Request-cfg-onOpen'>		/**
</span>		 * @cfg {Function} [onOpen]
		 * Callback called before sending an API request.
		 */
<span id='Echo-API-Request-cfg-onClose'>		/**
</span>		 * @cfg {Function} [onClose]
		 * Callback called after API request aborting.
		 */
<span id='Echo-API-Request-cfg-apiBaseURL'>		/**
</span>		 * @cfg {String} [apiBaseURL]
		 * Specifies the base URL for API requests
		 */
		&quot;apiBaseURL&quot;: &quot;//api.echoenabled.com/v1/&quot;,
<span id='Echo-API-Request-cfg-data'>		/**
</span>		 * @cfg {Object|String} [data]
		 * Data to be sent to the server. It is converted to a query string,
		 * if not already a string. Object must be key/value pairs.
		 */
		&quot;data&quot;: {},
<span id='Echo-API-Request-cfg-settings'>		/**
</span>		 * @cfg {Object} [settings]
		 * A set of the key/value pairs to configure the transport object.
		 * This configuration is passed to the transport object through the
		 * jQuery&#39;s ajaxSettings field.
		 * For more info see http://api.jquery.com/jQuery.ajax/.
		 * Note: according to the link above, for some transports these settings
		 * have no effect.
		 */
		&quot;onOpen&quot;: $.noop,
		&quot;onData&quot;: $.noop,
		&quot;onError&quot;: $.noop,
		&quot;onClose&quot;: $.noop,
<span id='Echo-API-Request-cfg-transport'>		/**
</span>		 * @cfg {String} [transport]
		 * Specifies the transport name. The following transports are available:
		 *
		 *  + &quot;websockets&quot;
		 *  + &quot;ajax&quot;
		 *  + &quot;jsonp&quot;
		 *  + &quot;XDomainRequest&quot; (only supported in IE8+)
		 *
		 */
		&quot;transport&quot;: &quot;ajax&quot;,
<span id='Echo-API-Request-cfg-method'>		/**
</span>		 * @cfg {String} [method]
		 * Specifies the request method. The following methods are available:
		 *
		 *  + &quot;GET&quot;
		 *  + &quot;POST&quot;
		 *
		 */
		&quot;method&quot;: &quot;GET&quot;,
<span id='Echo-API-Request-cfg-secure'>		/**
</span>		 * @cfg {Boolean} [secure]
		 * There is a flag which indicates what protocol will be used in, secure or not.
		 * If this parameter is not set, internally the lib will decide on the URL scheme.
		 */
		&quot;secure&quot;: false,
<span id='Echo-API-Request-cfg-timeout'>		/**
</span>		 * @cfg {Number} [timeout]
		 * Specifies the number of seconds after which the onError callback
		 * is called if the API request failed.
		 */
		&quot;timeout&quot;: 30
	}, function(key, value) {
		return self._configNormalizers[key]
			? self._configNormalizers[key].call(self, value)
			: value;
	});
	this.deferred = {
		&quot;transport&quot;: $.Deferred()
	};
	this.transport = this._getTransport();
};

Echo.API.Request.prototype._configNormalizers = {
	&quot;transport&quot;: function(transport) {
		if (typeof transport === &quot;string&quot;) {
			return this._normalizeTransportName(transport) || this._normalizeTransportName(&quot;ajax&quot;);
		} else {
			return this._normalizeTransportName(&quot;ajax&quot;);
		}
	}
};

Echo.API.Request.prototype._isSecureRequest = function(url) {
	var parts, secure = this.config.get(&quot;secure&quot;);
	var re = /https|wss/;
	if (secure) return secure;
	parts = utils.parseURL(url);
	return re.test(window.location.protocol) || re.test(parts.scheme);
};

<span id='Echo-API-Request-method-send'>/**
</span> * Method performing the API request using the given parameters.
 *
 * @param {Object} [args] Request parameters.
 * @param {Boolean} [args.force] Flag to initiate aggressive polling.
 */
Echo.API.Request.prototype.send = function(args) {
	var force = false;
	if (args) {
		force = args.force;
		delete args.force;
		this.config.extend(args);
		this.transport.config.extend(args);
	}
	var method = this[&quot;_&quot; + this.config.get(&quot;endpoint&quot;)];
	method &amp;&amp; method.call(this, force);
	return this.deferred.transport.promise();
};

//TODO: probably we should replace request with _request or simply not documenting it
Echo.API.Request.prototype.request = function(params) {
	var self = this;
	var timeout = this.config.get(&quot;timeout&quot;);
	if (this.transport) {
		this.transport.config.extend(
			$.extend(
				true,
				this.transport.config.getAsHash(),
				this._getTransportConfig()
			)
		);
		if (timeout &amp;&amp; this.config.get(&quot;onError&quot;)) {
			this._timeoutId = setTimeout(function() {
				self.config.get(&quot;onError&quot;)({
					&quot;result&quot;: &quot;error&quot;,
					&quot;errorCode&quot;: &quot;network_timeout&quot;
				}, {
					&quot;critical&quot;: true
				});
				self.transport.abort();
			}, timeout * 1000);
		}
		this.transport.send(params);
	}
	return this.deferred.transport.promise();
};

Echo.API.Request.prototype.abort = function() {
	this.transport &amp;&amp; this.transport.abort();
	clearTimeout(this._timeoutId);
	if (this.deferred.transport) {
		this.deferred.transport.reject();
	}
};

Echo.API.Request.prototype._normalizeTransportName = function(transport) {
	return utils.foldl(&quot;&quot;, Echo.API.Transports, function(constructor, acc, name) {
		if (transport.toLowerCase() === name.toLowerCase()) {
			return name;
		}
	});
};

Echo.API.Request.prototype._getTransport = function() {
	var self = this;
	var isSecure = this._isSecureRequest(this._prepareURL());
	var userDefinedTransport = this.config.get(&quot;transport&quot;);
	var transport = Echo.API.Transports[userDefinedTransport] &amp;&amp; Echo.API.Transports[userDefinedTransport].available()
		? userDefinedTransport
		: function() {
			var transport;
			$.each([&quot;WebSockets&quot;, &quot;AJAX&quot;, &quot;XDomainRequest&quot;, &quot;JSONP&quot;], function(i, name) {
				var available = Echo.API.Transports[name].available({
					&quot;secure&quot;: isSecure,
					&quot;method&quot;: self.config.get(&quot;method&quot;)
				});
				if (available) {
					transport = name;
					return false;
				}
			});
			return transport;
		}();
	return new Echo.API.Transports[transport](this._getTransportConfig());
};

Echo.API.Request.prototype._getTransportConfig = function() {
	var url = this._prepareURL();
	return $.extend(this._getHandlersByConfig(), {
		&quot;uri&quot;: url.replace(/^(?:(?:http|ws)s?:)?\/\//, &quot;&quot;),
		&quot;data&quot;: this.config.get(&quot;data&quot;),
		&quot;method&quot;: this.config.get(&quot;method&quot;),
		&quot;secure&quot;: this._isSecureRequest(url),
		&quot;settings&quot;: this.config.get(&quot;settings&quot;)
	});
};

Echo.API.Request.prototype._getHandlersByConfig = function() {
	var self = this;
	return utils.foldl({}, this.config.getAsHash(), function(value, acc, key) {
		var handler;
		if (/^on[A-Z]/.test(key) &amp;&amp; $.isFunction(value)) {
			handler = key !== &quot;onOpen&quot;
				? function() {
					var args = Array.prototype.slice.call(arguments);
					clearTimeout(self._timeoutId);
					value.apply(null, arguments);
					(self.deferred.transport[{
						&quot;onData&quot;: &quot;notifyWith&quot;,
						&quot;onError&quot;: &quot;rejectWith&quot;,
						&quot;onClose&quot;: &quot;resolveWith&quot;
					}[key]] || $.noop)
					.call(self.deferred.transport, null, args);
					if (key === &quot;onClose&quot; || key === &quot;onError&quot;) {
						self.deferred.transport = $.Deferred();
					}
				}
				: value;
			acc[key] = handler;
		}
	});
};

Echo.API.Request.prototype._prepareURL = function() {
	return this.config.get(&quot;apiBaseURL&quot;) + this.config.get(&quot;endpoint&quot;);
};

})(Echo.jQuery);
</pre>
</body>
</html>
