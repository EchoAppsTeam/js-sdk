<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(jQuery) {
&quot;use strict&quot;;

var $ = jQuery;

if (Echo.Utils.isComponentDefined(&quot;Echo.View&quot;)) return;

<span id='Echo-View-method-constructor'><span id='Echo-View'>/**
</span></span> * @class Echo.View
 * Class implementing core rendering logic, which is widely used across the system.
 * In addition to the rendering facilities, this class maintains the list of elements within
 * the given view (&quot;view elements collection&quot;) and provides the interface to access/update them.
 *
 *		var view = new Echo.View({
 *			&quot;cssPrefix&quot;: &quot;some-prefix-&quot;,
 *			&quot;renderers&quot;: {
 *				&quot;header&quot;: function(element) {
 *					// will return element as is
 *					return element;
 *				}
 *			},
 *			&quot;template&quot;: &#39;&lt;div class=&quot;some-prefix-container&quot;&gt;&#39; +
 *				&#39;&lt;div class=&quot;some-prefix-header&quot;&gt;{data:header}&lt;/div&gt;&#39; +
 *				&#39;&lt;div class=&quot;some-prefix-content&quot;&gt;{data:content}&lt;/div&gt;&#39; +
 *			&#39;&lt;/div&gt;&#39;,
 *			&quot;data&quot;: {
 *				&quot;header&quot;: &quot;Header text&quot;,
 *				&quot;content&quot;: &quot;Content text&quot;
 *			}
 *		});
 *
 *		view.render(); // will render the corresponding template
 *		view.get(&quot;content&quot;); // will return a jquery object with the className &quot;some-prefix-content&quot;
 *		view.get(&quot;header&quot;).text(); // will return &quot;Header text&quot;
 *		view.set(&quot;footer&quot;, $(&#39;&lt;div class=&quot;some-prefix-footer&quot;&gt;&#39;));
 *
 *		// will place the &quot;footer&quot; element after &quot;content&quot; element in the view
 *		view.get(&quot;footer&quot;).insertAfter(view.get(&quot;content&quot;));
 *
 *		var view2 = view.fork({
 *			&quot;renderers&quot;: {
 *				&quot;content&quot;: function(element) {
 *					return element.addClass(&quot;some-external-className&quot;);
 *				}
 *			}
 *		});
 *
 *		view2.render();
 *		view2 === view; // will return false
 *		view2.get(&quot;content&quot;).attr(&quot;class&quot;); // will return &quot;some-prefix-content some-external-className&quot;
 *		view.get(&quot;content&quot;).attr(&quot;class&quot;); // will return &quot;some-prefix-content&quot;
 *
 * @package environment.pack.js
 *
 * @constructor
 * Class constructor encapsulating templates rendering and renderers application mechanics.
 *
 * @param config
 * Specifies class configuration parameters.
 *
 * @param {String} [config.cssPrefix]
 * CSS class name prefix used by the Echo.View to detect whether a certain element
 * should be added into the view elements collection (if the element CSS class name
 * matches the prefix) and which renderer should be applied in case the element
 * satisfies the CSS prefix match condition.
 *
 * @param {Object} [config.renderers]
 * Object which specifies a set of renderers which should be applied during the template
 * rendering. The name of the element is used as a key, the renderer function as the value.
 *
 * @param {Function} [config.renderer]
 * Function to be applied for each element in the view elements collection.
 *
 * The &quot;renderer&quot; function must return the value of the &quot;target&quot; field of the incoming object.
 *
 * Additional notes:
 *
 * + if this parameter is defined, the &quot;renderers&quot; config field value will be ignored
 * + this function is for advanced use only, for most cases you should use the &quot;renderers&quot;
 * object instead
 *
 * @param {Object} config.renderer.args
 * Object which contains renderer specific information.
 *
 * @param {String} config.renderer.args.name
 * Name of the renderer specific for the current element
 *
 * @param {HTMLElement} config.renderer.args.target
 * Reference to jQuery object which represents the current element
 *
 * @param {Object} [config.renderer.args.extra]
 * The JS object with the set of extra parameters required to process
 * the current element
 *
 * @param {Object} [config.substitutions]
 * Object containing the list of extra instructions to be applied during template compilation.
 *
 * @param {Object} [config.data]
 * Object with the data to be inserted into the template into the {data:%KEY%} placeholder.
 * The {data:%KEY%} is a default placeholder supported by the Echo.View even if no
 * substitution rules were defined in the config via &quot;substitutions&quot; field.
 *
 * @param {String} [config.template]
 * Template which should be processed using a given substitution rules and
 * the set of renderers.
 * Note: in order to prevent elements overriding in the view elements collection,
 * make sure that the template defined in the Echo.View constructor call contains
 * elements with the unique CSS class names (matching the CSS prefix).
 */
Echo.View = function(config) {
	config = config || {};
	this.config = config;
	this.config.cssPrefix = this.config.cssPrefix || &quot;&quot;;
	this.renderers = config.renderers || {};
	this._clear();
};

<span id='Echo-View-method-get'>/**
</span> * Accessor function to get specific element in this view.
 *
 * This function returns the corresponding element if it exists in the view.
 *
 * @param {String} name
 * The name of the element in the view to be obtained.
 * The name equals to a CSS class name defined for the element minus the CSS prefix
 * defined in the Echo.View object config. For example, if an element has the
 * &quot;echo-item-container&quot; CSS class and the &quot;echo-item-&quot; CSS prefix was defined
 * during the object constructor call, the element will be available using
 * the &quot;container&quot; name. If element has more than one CSS class name matching
 * the CSS prefix - it will be available under multiple names.
 *
 * @return {Object}
 * The corresponding value found in the object.
 */
Echo.View.prototype.get = function(name) {
	return this._elements[this._key(name)];
};

<span id='Echo-View-method-set'>/**
</span> * Setter method to add element into the view elements collection.
 *
 * @param {String} name
 * The name of the element which should be added into the view elements collection.
 * See (link #get) to get more information about this field format.
 *
 * @param {Object|String} element
 * The corresponding DOM or jQuery element which should be added into collection.
 * The element might also be a HTML markup string which will be transformed into the
 * jQuery element before assignment.
 */
Echo.View.prototype.set = function(name, element) {
	this._elements[this._key(name)] = $(element);
};

<span id='Echo-View-method-remove'>/**
</span> * Method to remove a specific element from the view elements collection.
 *
 * @param {String|Object} element
 * The name of the element or the element itself to be removed from the collection.
 * See (link #get) to get more information about this field format in case of string name.
 */
Echo.View.prototype.remove = function(element) {
	var name = typeof element === &quot;string&quot;
		? this._key(element)
		: element.echo.name;
	this._elements[name].remove();
	delete this._elements[name];
};

<span id='Echo-View-method-rendered'>/**
</span> * Function which indicates whether the view was rendered or not.
 *
 * @return {Boolean}
 */
Echo.View.prototype.rendered = function() {
	return !!this._rendered;
};

<span id='Echo-View-method-render'>/**
</span> * Function to transform the template into the DOM representation and apply renderers.
 *
 * @param args
 * Specifies rendering parameters.
 *
 * @param {Object} [args.renderers]
 * Object which specifies a set of renderers which should be applied during the template
 * rendering. The name of the element is used as a key, the renderer function as the value.
 *
 * @param {Object} [args.substitutions]
 * Object containing the list of extra instructions to be applied during template compilation.
 *
 * @param {Object} [args.data]
 * Object with the data to be inserted into the template into the {data:%KEY%} placeholder.
 * The {data:%KEY%} is a default placeholder supported by the Echo.View even if no
 * substitution rules were defined in the config via &quot;substitutions&quot; field.
 *
 * @param {String} [args.template]
 * Template which should be processed using a given substitution rules and
 * the set of renderers.
 *
 * @return {Object}
 * DOM (jQuery element) representation of the given template using the rules specified.
 */
Echo.View.prototype.render = function(args) {
	args = args || {};
	args.data = args.data || this.config.data || {};
	args.template = args.template || this.config.template;

	// merge renderers passed into the &quot;render&quot; function
	// and the ones defined in the view config during initialization
	if (args.renderers) {
		$.extend(this.renderers, args.renderers);
	}

	// render specific element (recursively if specified)
	if (args.name) {
		args.target = args.target || this.get(args.name);
		if (!args.target) return false;
		var processor = args.recursive ? &quot;recursive&quot; : &quot;element&quot;;
		return this._render[processor].call(this, args);
	}

	// render template
	if (args.template) {
		this._clear();

		// save template to use it for
		// the recursive renderer application call
		this._template = typeof args.template === &quot;string&quot;
					? args.template
					: args.template.html();

		var dom = this._render.template.call(this, args);
		this._rendered = true;
		return dom;
	}

	// unknown action
	return false;
};

<span id='Echo-View-method-fork'>/**
</span> * Function which instantiates an Echo.View object with the config of the current instance.
 * This function is helpful when you need to process the template using the rules and
 * renderers specified for the parent Echo.View class instance.
 *
 * @param [config]
 * Configuration overrides object. See Echo.View class constructor
 * to get more information about the config object fields and types.
 *
 * @return {Object}
 * New Echo.View class instance with the configuration params taken from the current instance.
 */
Echo.View.prototype.fork = function(config) {
	return new Echo.View($.extend(true, {}, this.config, config));
};

// private functions

Echo.View.prototype._render = {};

Echo.View.prototype._render.element = function(args) {
	return this.config.renderer
		? this.config.renderer(args)
		: this._hasRenderer(args.name)
			? this._getRenderer(args.name)(args.target, args.extra)
			// no renderer found - nothing to render,
			// return non-modified target in this case
			: args.target;
};

Echo.View.prototype._render.recursive = function(args) {
	var oldNode = this.get(args.name);

	// define original template
	args.template = this._template;

	var dom = this._compileTemplate(args);
	this._applyRenderers($(&quot;.&quot; + this._key(args.name), dom));
	var newNode = this.get(args.name);
	oldNode.replaceWith(newNode);
	return newNode;
};

Echo.View.prototype._render.template = function(args) {
	var dom = this._compileTemplate(args);
	if (dom.hasClass(&quot;echo-tmp-wrapper&quot;)) {
		dom = $(dom.html());
	}
	return this._applyRenderers(dom);
};

Echo.View.prototype._key = function(name) {
	return this.config.cssPrefix + name;
};

Echo.View.prototype._clear = function() {
	this._elements = {};
};

Echo.View.prototype._compileTemplate = function(args) {
	// do not process if template is not a string
	if (typeof args.template !== &quot;string&quot;) {
		return args.template;
	}
	var template = Echo.Utils.substitute({
		&quot;data&quot;: args.data,
		&quot;template&quot;: args.template,
		&quot;instructions&quot;: this.config.substitutions,
		&quot;normalizer&quot;: function(v) {
			return v.toString().replace(/&quot;/g, &quot;&amp;quot;&quot;);
		}
	});
	return $(&#39;&lt;div class=&quot;echo-tmp-wrapper&quot;/&gt;&#39;).html(template);
};

Echo.View.prototype._applyRenderers = function(dom) {
	var view = this;
	var elements = this._getRenderableElements(dom);
	$.each(elements, function(name, element) {
		if (view._hasRenderer(name)) {
			view.render({
				&quot;name&quot;: name,
				&quot;target&quot;: element
			});
		}
	});
	return dom;
};

Echo.View.prototype._getRenderer = function(name) {
	return this.renderers[name];
};

Echo.View.prototype._hasRenderer = function(name) {
	return this.config.renderer ? true : !!this._getRenderer(name);
};

Echo.View.prototype._getRenderableElements = function(container) {
	var view = this, elements = {};
	var isRenderer = new RegExp(this.config.cssPrefix + &quot;(.*)$&quot;);
	container.find(&quot;*&quot;).addBack().each(function(i, element) {
		if (!element.className) {
			return;
		}
		var classes = element.className.split(/[ ]+/);
		$.each(classes, function(j, className) {
			var pattern = className.match(isRenderer);
			var name = pattern ? pattern[1] : undefined;
			if (name) {
				view.set(name, element);
				element = view.get(name);
				element.echo = element.echo || {};
				element.echo.name = className;
				elements[name] = element;
			}
		});
	});
	return elements;
};

})(Echo.jQuery);
</pre>
</body>
</html>
