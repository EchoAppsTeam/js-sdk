<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(jQuery) {
&quot;use strict&quot;;

var $ = jQuery;

Echo.Tests.module = function(name, config) {
	config = config || {};
	config.meta = config.meta || {};
	QUnit.module(name, {
		&quot;setup&quot;: function() {
			_testSetup();
			config.setup &amp;&amp; config.setup.call(this);
		},
		&quot;teardown&quot;: function() {
			config.teardown &amp;&amp; config.teardown.call(this);
			_testTeardown();
		},
		&quot;meta&quot;: {
			&quot;className&quot;: config.meta.className || &quot;&quot;,
			&quot;functions&quot;: config.meta.functions || []
		}
	});
};

Echo.Tests.test = function(name, callback, config) {
	config = _normalizeTestConfig(config);
	QUnit.test(name, function() {
		var self = this, args = arguments;
		// unfortunately user actualization process is async, we have to handle it
		// so we stop QUnit processing before test ...
		QUnit.stop();
		Echo.Tests.Utils.actualizeTestUser(config.user, function() {
			callback.apply(self, args);
			// ... and start it again after test
			QUnit.start();
		});
	});
};

Echo.Tests.asyncTest = function(name, callback, config) {
	config = _normalizeTestConfig(config);
	QUnit.test(name, function() {
		var self = this, args = arguments;
		// we might want individual timeout for each test
		// so we can&#39;t use QUnit.asyncTest, but we emulate it using QUnit.stop()
		QUnit.config.testTimeout = config.timeout;
		QUnit.stop();
		Echo.Tests.Utils.actualizeTestUser(config.user, function() {
			callback.apply(self, args);
		});
	});
};

Echo.Tests.renderersTest = function(component, params, config) {
	params = $.extend({
		&quot;appkey&quot;: &quot;echo.jssdk.tests.aboutecho.com&quot;,
		&quot;ready&quot;: function() {}
	}, params || {});

	Echo.Tests.asyncTest(&quot;basic checks for renderers&quot;, function() {
		var ready = params.ready;
		var handler = function() {
			var instance = this;
			ready.call(instance);
			_checkRenderers.call(instance, {
				&quot;instance&quot;: instance,
				&quot;renderers&quot;: instance.renderers,
				&quot;cssPrefix&quot;: instance.cssPrefix
			});
			instance.destroy();
			QUnit.start();
		};
		params.ready = function() {
			if (this.view.rendered()) {
				handler.call(this);
			} else {
				this.events.subscribe({
					&quot;topic&quot;: component + &quot;.onRender&quot;,
					&quot;once&quot;: true,
					&quot;handler&quot;: handler
				});
			}
		};
		params.target = params.target || $(&quot;#qunit-fixture&quot;);
		var Component = Echo.Utils.getComponent(component);
		new Component(params);
	}, config);
};

Echo.Tests.pluginRenderersTest = function(plugin, params, config) {
	params = $.extend({
		&quot;appkey&quot;: &quot;echo.jssdk.tests.aboutecho.com&quot;,
		&quot;plugins&quot;: [],
		&quot;ready&quot;: function() {}
	}, params || {});

	var parts = plugin.split(&quot;.Plugins.&quot;);
	var component = parts[0];
	plugin = parts[1];
	params.plugins.push($.extend({&quot;name&quot;: plugin}, params.pluginConfig || {}));
	delete params.pluginConfig;

	// XXX: hack this because Stream.Item can&#39;t be instantiated itself
	var forStreamItem = component.indexOf(&quot;Stream.Item&quot;) &gt;= 0;
	component = component.replace(&quot;Stream.Item&quot;, &quot;Stream&quot;);

	Echo.Tests.asyncTest(&quot;basic checks for renderers&quot;, function() {
		var ready = params.ready;
		var handler = function() {
			var instance = this;
			var pluginInstance = forStreamItem
				? instance.threads[0].getPlugin(plugin)
				: instance.getPlugin(plugin);
			ready.call(instance);
			_checkRenderers.call(pluginInstance, {
				&quot;instance&quot;: pluginInstance.component,
				&quot;renderers&quot;: pluginInstance._manifest(&quot;renderers&quot;),
				&quot;cssPrefix&quot;: pluginInstance.cssPrefix
			});
			_checkRenderers.call(pluginInstance, {
				&quot;instance&quot;: pluginInstance.component,
				&quot;renderers&quot;: pluginInstance._manifest(&quot;component&quot;).renderers,
				&quot;cssPrefix&quot;: pluginInstance.component.cssPrefix,
				&quot;statPrefix&quot;: &quot;component.&quot;
			});
			instance.destroy();
			QUnit.start();
		};
		params.ready = function() {
			if (this.view.rendered()) {
				handler.call(this);
			} else {
				this.events.subscribe({
					&quot;topic&quot;: component + &quot;.onRender&quot;,
					&quot;once&quot;: true,
					&quot;handler&quot;: handler
				});
			}
		};
		params.target = params.target || $(&quot;#qunit-fixture&quot;);
		var Component = Echo.Utils.getComponent(component);
		new Component(params);
	}, config);
};

Echo.Tests.isolate = function(test) {
	return function(cb) {
		var iframe = $(&#39;&lt;iframe name=&quot;&#39; + name + &#39;&quot; style=&quot;width: 0px; height: 0px; border: 0px; visibility: hidden; display: none&quot;&gt;&lt;/iframe&gt;&#39;);
		$(document.body).append(iframe);
		iframe.on(&quot;load&quot;, function() {
			var win = iframe.get(0).contentWindow;
			var callback = function() {
				// cleanup first
				iframe.remove();
				// and then execute callback to advance to the next test
				cb();
			};
			test.call(win, callback);
		});
		iframe.attr(&quot;src&quot;, &quot;//echoappsteam.github.io/js-sdk/tests/blank.html&quot;);
	};
};

Echo.Tests.jqueryObjectsEqual = function(actual, expected, message) {
	var properties = [
		&quot;disabled&quot;,
		&quot;readOnly&quot;,
		&quot;tagName&quot;
	];
	var attributes = [
		&quot;autocomplete&quot;,
		&quot;aria-activedescendant&quot;,
		&quot;aria-controls&quot;,
		&quot;aria-describedby&quot;,
		&quot;aria-disabled&quot;,
		&quot;aria-expanded&quot;,
		&quot;aria-haspopup&quot;,
		&quot;aria-hidden&quot;,
		&quot;aria-labelledby&quot;,
		&quot;aria-pressed&quot;,
		&quot;aria-selected&quot;,
		&quot;aria-valuemax&quot;,
		&quot;aria-valuemin&quot;,
		&quot;aria-valuenow&quot;,
		&quot;class&quot;,
		&quot;href&quot;,
		&quot;id&quot;,
		&quot;nodeName&quot;,
		&quot;role&quot;,
		&quot;tabIndex&quot;,
		&quot;src&quot;,
		&quot;alt&quot;,
		&quot;title&quot;
	];
	function extract(elem) {
		if (!elem || !elem.length) {
			return {};
		}
		var children, result = {};
		$.map(properties, function(attr) {
			var value = elem.prop(attr);
			if (typeof value !== &quot;undefined&quot;) {
				result[attr] = value;
			}
		});
		$.map(attributes, function(attr) {
			var value = elem.attr(attr);
			if (typeof value !== &quot;undefined&quot;) {
				result[attr] = value;
			}
		});
		result.events = $._data(elem[0], &quot;events&quot;);
		result.data = $.extend({}, elem.data());
		delete result.data[$.expando];
		children = elem.contents();
		if (children.length) {
			result.children = children.map(function( ind ) {
				return extract($(this));
			}).get();
		} else {
			result.text = elem.text();
		}
		$.each([&quot;events&quot;], function(i, p) {
			if (typeof result[p] === &quot;undefined&quot;) {
				delete result[p];
			}
		});
		return result;
	}
	if (!expected || !expected.length) {
		QUnit.pushFailure(message + &quot; (expected value must not be empty or undefined)&quot;);
		return;
	}
	QUnit.deepEqual(extract(actual), extract(expected), message);
};

// methods useful if one wants to disable particular test easily
Echo.Tests._test = Echo.Tests._asyncTest = Echo.Tests._renderersTest = function() {
	Echo.Utils.log({
		&quot;component&quot;: &quot;Tests&quot;,
		&quot;message&quot;: &quot;[&quot; + QUnit.config.currentModule + &quot;] Disabled test: &quot; + arguments[0]
	});
};

// private functions

function _testSetup() {
	//delete all event handlers in all contexts
	Echo.Events._subscriptions = {};
	Echo.Events._dataByHandlerId = {};

	// delete all accumulated stuff from Loader except resources state
	// because yepnope has the same info and we don&#39;t want it unsynchronized
	var resources = Echo.Loader.vars.state.resources;
	Echo.Loader.canvases = [];
	Echo.Loader.overrides = {};
	Echo.Loader.vars = {
		&quot;state&quot;: {&quot;resources&quot;: resources, &quot;queue&quot;: []},
		&quot;processing&quot;: false,
		&quot;syncQueue&quot;: []
	};

	// clear qunit-fixture
	$(&quot;#qunit-fixture&quot;).empty();
};

function _testTeardown() {
	var meta = QUnit.config.current.moduleTestEnvironment.meta;
	if (!meta || meta.processed) return;
	meta.processed = true;
	$.each(meta.functions, function(i, name) {
		Echo.Tests.Stats.markFunctionTested(meta.className + &quot;.&quot; + name);
	});
};

function _normalizeTestConfig(config) {
	return $.extend(true, {
		&quot;timeout&quot;: 5000,
		&quot;user&quot;: {
			&quot;status&quot;: &quot;anonymous&quot;
		}
	}, config || {});
}

function _checkSingleRenderer(name, element, rendererFn, suffix) {
	suffix = suffix || &quot;&quot;;
	if (!element) {
		QUnit.ok(true, &quot;Note: the test for the &quot; + &quot; \&quot;&quot; + name + &quot;\&quot;&quot; + &quot; renderer was not executed, because the template doesn&#39;t contain the respective element. This renderer works for another type of template.&quot; + suffix);
		return;
	}
	var oldElement = element.clone(true, true);
	var renderedElement = rendererFn.call(this, element);
	_testElementsConsistencyAfterRendering(name, oldElement, renderedElement, suffix);
}

function _checkRenderers(config) {
	var self = this;
	var instance = config.instance;
	var renderers = config.renderers;
	config.statPrefix = config.statPrefix || &quot;&quot;;
	$.each(renderers, function(name, renderer) {
		QUnit.config.current.moduleTestEnvironment.meta.functions.push(config.statPrefix + &quot;renderers.&quot; + name);
		_checkSingleRenderer.call(self, name, (config.statPrefix ? instance : self).view.get(name), renderers[name]);
	});
	var oldElements = Echo.Utils.foldl({}, instance.view._elements, function(element, acc, name) {
		acc[name] = element.clone(true, true);
	});
	instance.render();
	$.each(renderers, function(name, element) {
		_checkSingleRenderer.call(self, name, oldElements[config.cssPrefix + name], renderers[name], &quot; (recursive rerendering case)&quot;);
	});
}

function _testElementsConsistencyAfterRendering(name, oldElement, renderedElement, suffix) {
	var prefix = &quot;Renderer \&quot;&quot; + name + &quot;\&quot;: &quot;;
	suffix = suffix || &quot;&quot;;
	QUnit.ok(
		renderedElement instanceof jQuery &amp;&amp; renderedElement.length === 1,
		prefix + &quot;check contract&quot; + suffix
	);
	QUnit.ok(
		renderedElement.jquery === oldElement.jquery,
		prefix + &quot;check that element is still the same after second rendering&quot; + suffix
	);
	QUnit.equal(
		renderedElement.children().length,
		oldElement.children().length,
		prefix + &quot;check the number of children after second rendering of element&quot; + suffix
	);
	// Some renderers may add computed numbers or dates to element HTML so it
	// may become different in the 2 sequential executions. We still consider such
	// renderers valid that&#39;s why we replace any number of digits in the element
	// text with a single &quot;0&quot; symbol for new text and old text to match
	var oldText = oldElement.text().toLowerCase().replace(/\d+/g, &quot;0&quot;);
	var newText = renderedElement.text().toLowerCase().replace(/\d+/g, &quot;0&quot;);
	QUnit.equal(
		newText,
		oldText,
		prefix + &quot;check that text representation of the element is still the same after second rendering&quot; + suffix
	);
};
// TODO: remove this line when all tests use new format
Echo.Tests._testElementsConsistencyAfterRendering = _testElementsConsistencyAfterRendering;

})(Echo.jQuery);
</pre>
</body>
</html>
