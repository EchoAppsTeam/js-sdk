<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">(function(jQuery) {
&quot;use strict&quot;;

var $ = jQuery;

if (!window.Echo) window.Echo = {};

if (Echo.Utils) return;

if (!Echo.Variables) Echo.Variables = {};

<span id='Echo-Utils'>/**
</span> * Static class implements common methods of data processing.
 * The Echo.Utils class is used in various places of Echo JS SDK components.
 *
 * @package environment.pack.js
 */

Echo.Utils = {};

Echo.Utils.cache = {};

Echo.Utils.regexps = {
	&quot;templateSubstitution&quot;: &quot;{([0-9a-z\\.]+)(?:\\:((?:[0-9a-z_-]+\\.)*[0-9a-z_-]+))?}&quot;,
	&quot;mobileUA&quot;: /mobile|midp-|opera mini|iphone|ipad|blackberry|nokia|samsung|docomo|symbian|windows ce|windows phone|android|up\.browser|ipod|netfront|skyfire|palm|webos|audiovox/i,
	&quot;w3cdtf&quot;: /^(\d{4})(?:-(\d\d)(?:-(\d\d))?(?:(?:T(\d\d):(\d\d):(\d\d))(?:\.(\d{1,3}))?(?:Z|(?:(\+|-)(\d\d):(\d\d))))?)?$/,
	&quot;parseURL&quot;: /^(?:(?:([^:\/\?#]+):)?\/\/)?([^:\/\?#]*)?(?::(\d+))?([^\?#]*)(?:\?([^#]*))?(?:#(.*))?/,
	&quot;stripTags&quot;: /&lt;!--[\s\S]*?--&gt;|&lt;\/?[a-z][a-z0-9]*\b[^&gt;]*&gt;/gi
};

<span id='Echo-Utils-static-method-addCSS'>/**
</span> * @static
 * Method to add CSS styles on the page.
 *
 * This function adds CSS styles to the style tag which is placed in the head
 * of the document. The first argument is a string that contains CSS styles,
 * the second one is the unique identity string of CSS styles to be added.
 * If CSS styles with corresponding id were added before then this function
 * returns false.
 *
 *     // style tag in the head of HTML document
 *     // &lt;style&gt;
 *     //     .example-class { font-size: 12px; }
 *     // &lt;/style&gt;
 *
 *     Echo.Utils.addCSS(
 *         &#39;.echo-class { font-size: 14px; }&#39;
 *         , &#39;echo-class-id&#39;);
 *     // returns true because styles with id = &#39;echo-class-id&#39; weren&#39;t added before
 *     // &lt;style&gt;
 *     //     .example-class { font-size: 12px; }
 *     //     .echo-class { font-size: 14px; }
 *     // &lt;/style&gt;
 *
 *     Echo.Utils.addCSS(
 *         &#39;.echo-new-class { font-size: 16px; }&#39;
 *         , &#39;echo-class-id&#39;);
 *     // returns false because styles with id = &#39;echo-class-id&#39; were added before
 *
 * @param {String} cssCode
 * Contains CSS styles to be added.
 *
 * @param {String} id
 * Unique identity string of the CSS styles set.
 *
 * @return {Boolean}
 * true if CSS styles was successfully added, false - if CSS styles are already
 * in the document.
 */
Echo.Utils.addCSS = function(cssCode, id) {
	if (typeof this.cache.cssStyles === &quot;undefined&quot;) {
		this.cache.cssStyles = {
			&quot;anchor&quot;: undefined,
			&quot;index&quot;: 1,
			&quot;processed&quot;: {}
		};
	}
	var cssStyles = this.cache.cssStyles;
	if (id) {
		if (Echo.Utils.hasCSS(id)) return false;
		cssStyles.processed[id] = true;
	}
	var currentCssCode = &quot;&quot;;
	var oldStyle = cssStyles.anchor;
	if (oldStyle &amp;&amp; oldStyle.length) {
		currentCssCode = oldStyle.html();
	}
	// IE limit is 4095 rules per style tag
	// so we limit it to 100000 characters
	// (2000 rules x 50 characters per rule)
	if (currentCssCode.length + cssCode.length &gt; 100000) {
		cssStyles.index++;
		oldStyle = null;
		currentCssCode = &quot;&quot;;
	}
	var newStyle = $(&#39;&lt;style id=&quot;echo-css-rules-&#39; + cssStyles.index + &#39;&quot; type=&quot;text/css&quot;&gt;&#39; + currentCssCode + &quot;\n&quot; + cssCode + &#39;&lt;/style&gt;&#39;);
	if (oldStyle &amp;&amp; oldStyle.length) {
		// use replacing instead of adding css to existing element
		// because IE doesn&#39;t allow it
		oldStyle.replaceWith(newStyle);
	} else {
		if (cssStyles.anchor) {
			cssStyles.anchor.after(newStyle);
		} else {
			$(document.getElementsByTagName(&quot;head&quot;)[0] || document.documentElement).prepend(newStyle);
		}
	}
	cssStyles.anchor = newStyle;
	return true;
};

<span id='Echo-Utils-static-method-hasCSS'>/**
</span> * @static
 * Method to check whether the given set of CSS rules was already added into the page.
 *
 * This function might be used in conjunction with the Echo.Utils.addCSS function
 * to check certain conditions before adding new styles.
 *
 * @param {String} id
 * Unique identity string of the CSS styles set.
 *
 * @return {Boolean}
 * ‘true’ if the given CSS styles set was previously added into the page,
 * otherwise ‘false’.
 */
Echo.Utils.hasCSS = function(id) {
	return this.cache.cssStyles
		? !!this.cache.cssStyles.processed[id]
		: false;
};

<span id='Echo-Utils-static-method-foldl'>/**
</span> * @static
 * Method implementing folding mechanism.
 *
 * This function iterates over each value of the object passing them to
 * callback function. The first argument is the object that is available
 * in callback function to accumulate items.
 *
 *     var array = Echo.Utils.foldl([], [1, 2, 3], function(item, acc) {
 *         acc.push(item);
 *     }); // array will be [1, 2, 3];
 *
 *     var hash = Echo.Utils.foldl({}, {&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;}, function(item, acc, key) {
 *         if (key === &quot;key2&quot;) return;
 *         acc[key] = item;
 *     }); // hash will be {&quot;key1&quot;: &quot;value1&quot;};
 *
 * @param {Object|Array} acc
 * Defines the initial accumulator.
 *
 * @param {Object|Array} object
 * The object to be folded.
 *
 * @param {Function} callback
 * The callback function executed for each item of the object to be folded.
 *
 * @param {Object} callback.item
 * The item of the object to iterate over.
 *
 * @param {Object|Array} callback.acc
 * The object that accumulates items.
 *
 * @param {String} [callback.key]
 * Defines the key of iterated items.
 *
 * @return {Object|Array}
 * The resulting object
 */
Echo.Utils.foldl = function(acc, object, callback) {
	var result;
	$.each(object, function(key, item) {
		result = callback(item, acc, key);
		if (result !== undefined) {
			acc = result;
		}
	});
	return acc;
};

<span id='Echo-Utils-static-method-get'>/**
</span> * @static
 * Method to get a specific field value in the given object.
 *
 * This function returns the corresponding value of the given object field or the
 * default value if specified as the third argument. Use the dot char (&#39;.&#39;) as the
 * delimiter of the key parts to get the nested field value.
 *
 *     var data = {
 *         &quot;key1&quot;: &quot;value1&quot;,
 *         &quot;key2&quot;: {
 *             &quot;key2-1&quot;: &quot;value2-1&quot;
 *         }
 *     };
 *
 *     Echo.Utils.get(data, &quot;key1&quot;); // returns &quot;value1&quot;
 *     Echo.Utils.get(data, &quot;key2&quot;); // returns object {&quot;key2-1&quot;: &quot;value2-1&quot;}
 *     Echo.Utils.get(data, &quot;key2.key2-1&quot;); // returns &quot;value2-1&quot;
 *
 * @param {Object} obj
 * The source object where the value defined for the given key should be looked for.
 *
 * @param {Mixed} key
 * Specifies the field to access the necessary value.
 * Possible types are String or Array. If the key is defined as an Array,
 * the parameter should contain the key chain to access the necessary value.
 * Example: the &quot;key2.key2-2&quot; and [&quot;key2&quot;, &quot;key2-2&quot;] key representations are equivalent.
 *
 * @param {Object} [defauts]
 * Default value to be returned in case when no corresponding key was found
 * in the specified object.
 *
 * @param {Function} [callback]
 * The callback function to be executed while switching between the nesting levels
 * while traversing the source object. The callback is executed once in case of the
 * plain keys (i.e. without nesting levels).
 *
 * @param {Object} callback.data
 * Contains the object value on the current nesting level during the object traversing.
 *
 * @param {String} callback.key
 * Contains the part of the key to be used during this iteration of the object traversing.
 *
 * @return {Mixed}
 * The corresponding value found in the source object or the default value
 * (if defined during the function call) in case the specified field is not found
 * or its value is undefined.
 */
Echo.Utils.get = function(obj, key, defaults, callback) {
	var keys = Echo.Utils._prepareFieldAccessKey(key);
	if (!keys || !obj) return defaults;
	var found = true;
	var iteration = function(_key, _data) {
		if (callback) {
			callback(_data, _key);
		}
		if (typeof _data[_key] === &quot;undefined&quot;) {
			found = false;
		} else {
			return _data[_key];
		}
	};
	// avoid foldl usage for plain keys
	var value = keys.length === 1
		? iteration(keys.pop(), obj)
		: Echo.Utils.foldl(obj, keys, iteration);
	return found ? value : defaults;
};

<span id='Echo-Utils-static-method-remove'>/**
</span> * @static
 * Method to remove a specific field from the given object.
 *
 * This function removes the corresponding field in the target object.
 * Use the dot char (&#39;.&#39;) as a delimiter of the key parts to remove nested field.
 *
 *     var data = {
 *         &quot;key1&quot;: &quot;value1&quot;,
 *         &quot;key2&quot;: {
 *             &quot;key2-1&quot;: &quot;value2-1&quot;,
 *             &quot;key2-2&quot;: {
 *                 &quot;key2-2-1&quot;: &quot;value2-2-1&quot;
 *             }
 *         }
 *     };
 *
 *     Echo.Utils.remove(data, &quot;key1&quot;); // returns true and key1 delete
 *     Echo.Utils.remove(data, &quot;key2&quot;); // returns true and key2 delete
 *     Echo.Utils.remove(data, &quot;key2.key2-2.key2-2-1&quot;); // returns true and obj.key2.key2-2 returns empty object
 *     Echo.Utils.remove(data, &quot;not_defined_key&quot;); // returns false
 *
 * @param {Object} obj
 * Specifies the target object which should be updated.
 *
 * @param {Mixed} key
 * The key for value removing. Possible types are String or Array. If its Array, parameter
 * should contains list of keys if its complex. Ex.: &quot;key2.key2-2&quot; =&gt; [&quot;key2&quot;, &quot;key2-2&quot;].
 *
 * @return {Boolean}
 * The boolean value which indicates whether the key was removed from the given object.
 */
Echo.Utils.remove = function(obj, key) {
	var keys = Echo.Utils._prepareFieldAccessKey(key);
	if (!keys || !obj) return false;
	var field = keys.pop();
	// passing obj as a default value as well
	// to operate with it in case of the plain key
	var target = Echo.Utils.get(obj, keys, obj);
	return target === null || typeof target[field] === &quot;undefined&quot;
		? false
		: delete target[field];
};

<span id='Echo-Utils-static-method-set'>/**
</span> * @static
 * Method to define a given value for the specified key in the target object.
 *
 * This function allows to define the value for the corresponding field in the object.
 * Use the dot char (&#39;.&#39;) as a delimiter of the key parts to define nested field value.
 *
 *     var data = {
 *         &quot;key1&quot;: &quot;value1&quot;,
 *         &quot;key2&quot;: {
 *             &quot;key2-1&quot;: &quot;value2-1&quot;
 *         }
 *     };
 *
 *     Echo.Utils.set(data, &quot;key1&quot;, &quot;new value&quot;); // data[&quot;key1&quot;] will be &quot;new value&quot;
 *     Echo.Utils.set(data, &quot;key1&quot;, {&quot;key1-1&quot;: &quot;value1-1&quot;}); // data[&quot;key1&quot;] will be {&quot;key1-1&quot;:&quot;value1-1&quot;}
 *
 * @param {Object} obj
 * Specifies the target object which should be updated.
 *
 * @param {String} key
 * Defines the key where the given value should be stored.
 *
 * @param {Mixed} value
 * The data which should be defined for the given key.
 *
 * @return {Boolean}
 * The boolean value which indicates whether the necessary value was defined
 * for the target object using the key specified. Returns the &#39;false&#39; boolean value
 * in case the object or the key is not specified.
 */
Echo.Utils.set = function(obj, key, value) {
	var keys = Echo.Utils._prepareFieldAccessKey(key);
	if (!keys || !obj) return false;
	var field = keys.pop();
	var target = obj;
	if (keys.length &gt; 0) {
		target = Echo.Utils.get(obj, keys, undefined, function(acc, v) {
			if (typeof acc[v] === &quot;undefined&quot;) {
				acc[v] = {};
			}
		});
	}
	target[field] = value;
	return true;
};

Echo.Utils._prepareFieldAccessKey = function(key) {
	if (!key) return false;
	return typeof key === &quot;string&quot;
		? key.split(&quot;.&quot;)
		: key instanceof Array &amp;&amp; key.length
			? key
			: false; // unknown key type
};

<span id='Echo-Utils-static-method-htmlize'>/**
</span> * @static
 * Method to convert special characters to HTML entities.
 *
 * Some characters have special significance in HTML and should be represented by
 * HTML entities if they are to preserve their meanings. This function returns a
 * string with these conversions made.
 *
 *     Echo.Utils.htmlize(&quot;special characters: &amp;&lt;&gt;&quot;); // returns &quot;special characters: &amp;amp;&amp;lt;&amp;gt;&quot;
 *
 * Note: the function works with the &quot;string&quot; type argument only.
 * If the type of the value passed to the function differs from the &quot;string&quot; type,
 * the same value is returned with no changes.
 *
 * @param {String} text
 * The string to be converted.
 *
 * @return {String}
 * Converted string.
 */
Echo.Utils.htmlize = function(text) {
	return typeof text === &quot;string&quot; ? $(&quot;&lt;div&gt;&quot;).text(text).html() : text;
};

<span id='Echo-Utils-static-method-objectToJSON'>/**
</span> * @static
 * Method to convert JavaScript value to JavaScript Object Notation (JSON) string.
 *
 * These methods convert JavaScript object to JSON string. 
 * This function uses JSON.stringify() method if it is available in the browser.
 *
 *     Echo.Utils.objectToJSON(null); // returns &#39;null&#39;
 *     Echo.Utils.objectToJSON(123); // returns &#39;123&#39;
 *     Echo.Utils.objectToJSON(Number.POSITIVE_INFINITY); // returns &#39;null&#39;
 *     Echo.Utils.objectToJSON(&quot;string\n&quot;); // returns &#39;&quot;string\n&quot;&#39;
 *     Echo.Utils.objectToJSON(true); // returns true
 *     Echo.Utils.objectToJSON([&quot;value1&quot;, &quot;value2&quot;]); // returns &#39;[&quot;value1&quot;,&quot;value2&quot;]&#39;
 *     Echo.Utils.objectToJSON({&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;}); // returns &#39;{&quot;k1&quot;:&quot;v1&quot;,&quot;k2&quot;:&quot;v2&quot;}&#39;
 *
 * @param {Mixed} obj
 * The value to be converted.
 *
 * @return {String}
 * String containing JSON.
 */
Echo.Utils.objectToJSON = function(obj) {
	if (window.JSON &amp;&amp; JSON.stringify) {
		return JSON.stringify(obj);
	}
	// object -&gt; JSON conversion support for IE7
	var container;
	var encodeJSONLiteral = function(string) {
		var replacements = {
			&#39;\b&#39;: &#39;\\b&#39;,
			&#39;\t&#39;: &#39;\\t&#39;,
			&#39;\n&#39;: &#39;\\n&#39;,
			&#39;\f&#39;: &#39;\\f&#39;,
			&#39;\r&#39;: &#39;\\r&#39;,
			&#39;&quot;&#39;: &#39;\\&quot;&#39;,
			&#39;\\&#39;: &#39;\\\\&#39;
		};
		return string.replace(/[\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff\\]/g,
			function (a) {
				return (replacements.hasOwnProperty(a))
					? replacements[a]
					: &#39;\\u&#39; + (&#39;0000&#39; + a.charCodeAt(0).toString(16)).slice(-4);
			});
	};

	var out;
	switch (typeof obj) {
		case &quot;number&quot;: out = isFinite(obj) ? obj : &#39;null&#39;; break;
		case &quot;string&quot;: out = &#39;&quot;&#39; + encodeJSONLiteral(obj) + &#39;&quot;&#39;; break;
		case &quot;boolean&quot;: out = obj.toString(); break;
		default:
			if (obj instanceof Array) {
				container = $.map(obj, function(element) { return Echo.Utils.objectToJSON(element); });
				out = &#39;[&#39; + container.join(&quot;,&quot;) + &#39;]&#39;;
			} else if (obj instanceof Object) {
				var source = obj.exportProperties || obj;
				container = Echo.Utils.foldl([], source, function(value, acc, property) {
					if (source instanceof Array) {
						property = value;
						value = obj[property];
					}
					acc.push(&#39;&quot;&#39; + property + &#39;&quot;:&#39; + Echo.Utils.objectToJSON(value));
				});
				out = &#39;{&#39; + container.join(&quot;,&quot;) + &#39;}&#39;;
			} else {
				out = &#39;null&#39;;
			}
	}
	return out;
};

<span id='Echo-Utils-static-method-htmlTextTruncate'>/**
</span> * @static
 * Method to truncate HTML text.
 *
 * This function truncates HTML contents preserving the right HTML structure
 * and without truncating tags. If truncation hits the middle of the word, the word
 * itself is preserved and truncation starts right after this word.
 *
 *     Echo.Utils.htmlTextTruncate(&quot;Welcome to Echo SDK&quot;, 5, &quot;...&quot;); // returns &quot;Welcome...&quot;
 *     Echo.Utils.htmlTextTruncate(&quot;&lt;div&gt;Welcome to Echo SDK&quot;, 5, &quot;&quot;, true); // returns &quot;&lt;div&gt;Welcome&lt;/div&gt;&quot;
 *     Echo.Utils.htmlTextTruncate(&quot;&lt;div&gt;Welcome to Echo SDK&lt;/div&gt;&quot;, 3, &quot;...&quot;, true); // returns &quot;&lt;div&gt;Welcome...&lt;/div&gt;&quot;
 *     Echo.Utils.htmlTextTruncate(&quot;&lt;div&gt;Welcome to Echo SDK&lt;/div&gt;&quot;, 17, &quot;...&quot;, true); // returns &quot;&lt;div&gt;Welcome to Echo SDK&lt;/div&gt;&quot;
 *
 * @param {String} text
 * The string to be truncated.
 *
 * @param {Number} limit
 * The length of returned string without HTML tags.
 *
 * @param {String} postfix
 * The string to be added to truncated string.
 *
 * @param {Boolean} forceClosingTags
 * This parameter takes effect only when no truncation was performed. Otherwise
 * (when the content was truncated) the function restores the HTML structure
 * regardless of the forseClosingTags parameter value.
 *
 * @return {String}
 * Truncated string.
 */
Echo.Utils.htmlTextTruncate = function(text, limit, postfix, forceClosingTags) {
	if (!limit || text.length &lt; limit) return text;

	var i, tags = [], count = 0, finalPos = 0;
	var wordRegex = /(\w)+/;
	var htmlSpecialCharRegex = /^(\S)+;/;
	if (!this.cache.standaloneTags) {
		this.cache.standaloneTags =
			Echo.Utils.foldl(
				{},
				&quot;br hr input img area param base link meta option&quot;.split(&quot; &quot;),
				function(value, acc, key) { acc[value] = true; }
			);
	}

	for (i = 0; i &lt; text.length; i++) {
		var symbol = text.charAt(i);
		if (symbol === &quot;&lt;&quot;) {
			var tail = text.indexOf(&quot;&gt;&quot;, i);
			if (tail &lt; 0) return text;
			var source = text.substring(i + 1, tail);
			var tag = &quot;&quot;;
			var isTagClosing = false;
			if (source.charAt(0) === &quot;/&quot;) {
				isTagClosing = true;
				source = source.substring(1);
			}
			tag = source.match(wordRegex)[0];
			if (isTagClosing) {
				var current = tags.pop();
				if (!current || current !== tag) return text;
			} else if (!this.cache.standaloneTags[tag]) {
				tags.push(tag);
			}
			i = tail;
		} else if (symbol === &quot;&amp;&quot; &amp;&amp; text.substring(i).match(htmlSpecialCharRegex)) {
			i = text.indexOf(&quot;;&quot;, i);
			count++;
		} else {
			if (count &gt;= limit) {
				finalPos = i;
				break;
			}
			count++;
		}
	}
	if (finalPos || forceClosingTags) {
		if (finalPos) {
			var cut = text.substring(finalPos - 1, text.length - 1).match(/^\w+/);
			if (cut) {
				finalPos += cut[0].length - 1;
			}
			if (finalPos !== text.length - 1) {
				text = text.substring(0, finalPos) + (postfix || &quot;&quot;);
			}
		}
		for (i = tags.length - 1; i &gt;= 0; i--) {
			text += &quot;&lt;/&quot; + tags[i] + &quot;&gt;&quot;;
		}
	}
	return text;
};

<span id='Echo-Utils-static-method-stripTags'>/**
</span> * @static
 * Method to strip HTML tags from the string.
 *
 * This function returns a string with all HTML tags stripped from the given string.
 *
 *     Echo.Utils.stripTags(&quot;&lt;div&gt;Content&lt;/div&gt;&quot;); // returns &quot;Content&quot;
 *
 * Note: the function works with the &quot;string&quot; type argument only. If the value with
 * type different from &quot;string&quot; is passed to the function, the same value would be
 * returned with no changes.
 *
 * @param {String} text
 * The string to be stripped.
 *
 * @return {String}
 * Stripped string.
 */
Echo.Utils.stripTags = function(text) {
	if (typeof text !== &quot;string&quot;) return text;
	var old = &quot;&quot;;
	while (text !== old) {
		old = text;
		text = text.replace(Echo.Utils.regexps.stripTags, &quot;&quot;);
	}
	return text;
};

<span id='Echo-Utils-static-method-sanitize'>/**
</span> * @static
 * Method allowing to sanitize user generated data using a number of
 * predefined rules.
 *
 * @param {String} value
 * The string to be sanitized.
 *
 * @param {String} type
 * Type of the input value allowing to select appropriate sanitization rules.
 * Can be one of the following values:
 *
 *   + number - performs direct translation to number, if any symbol not
 *     allowed in a number is met, `undefined` value is returned.
 *   + plainText - strips all HTML tags using #stripTags method.
 *   + html - only breaks event handler attribute names like &quot;onmouseover&quot;
 *     to prevent some XSS attacks.
 *   + url - declines strings starting with &quot;javascript:&quot; or &quot;vbscript:&quot;
 *     (with preceeding whitespaces), useful to prevent XSS attacks through
 *     HTML attributes.
 *
 * @return {Mixed}
 * Sanitized value if the input was good enough or `undefined` if it was not.
 */
Echo.Utils.sanitize = function(value, type) {
	if (type === &quot;number&quot;) {
		value = +value;
		return isNaN(value) ? undefined : value;
	}

	if (type === &quot;plainText&quot;) {
		return Echo.Utils.stripTags(value);
	}

	if (type === &quot;html&quot;) {
		// We intentionally break HTML attributes starting with &quot;on&quot;.
		// These attributes are only event handlers anyway and we don&#39;t want them.
		// This action doesn&#39;t allow HTML strings like &quot;&lt;img src=# onerror=alert(1)&gt;&quot;
		// to execute JavaScript
		return value.replace(/(&lt;[^&gt;]+?\bon)([^&gt;]+&gt;)/ig, &quot;$1_$2&quot;);
	}

	if (type === &quot;url&quot;) {
		// drop any chars with code [0-32] from the beginning
		value = value.replace(/^[\x00-\x20]+/, &quot;&quot;);
		// perform some magic if value doesn&#39;t start with a single slash (which is relative path)
		if (value.charAt(0) !== &quot;/&quot; || value.charAt(1) !== &quot;/&quot;) {
			var prefix = &quot;&quot;;
			while (true) {
				// remove any whitespace from the first 11 symbols of value,
				// (11 is simply a length of &quot;javascript:&quot; string)
				prefix = value.substring(0, 11);
				if (!/\s/.test(prefix)) break;
				value = prefix.replace(/\s/g, &quot;&quot;) + value.substring(11);
			}
		}
		if (/^(?:java|vb)script:/i.test(value)) return undefined;
	}

	return value;
};

<span id='Echo-Utils-static-method-parseURL'>/**
</span> * @static
 * Method to parse the URL and return its parts.
 *
 * This function parses a URL and returns a hash containing parts of the URL
 * which are presented. This function is not meant to validate the given URL,
 * it only breaks it up into the parts.
 *
 *     var url = &quot;http://domain.com:8080/some/path/?query_string#hash_value&quot;;
 *     Echo.Utils.parseURL(url);
 *     // returns {
 *     //     &quot;scheme&quot;: &quot;http&quot;,
 *     //     &quot;domain&quot;: &quot;domain.com&quot;,
 *     //     &quot;port&quot;: &quot;8080&quot;,
 *     //     &quot;path&quot;: &quot;/some/path/&quot;
 *     //     &quot;query&quot;: &quot;query_string&quot;,
 *     //     &quot;fragment&quot;: &quot;hash_value&quot;
 *     // };
 *
 * @param {String} url
 * The URL to be parsed.
 *
 * @return {Object}
 * Object containing the following parts of the URL as fields:
 * scheme, domain, path, query, fragment.
 * Field will contain empty string if the corresponding part of the URL didn&#39;t match.
 */
Echo.Utils.parseURL = function(url) {
	if (typeof this.cache.parsedURLs === &quot;undefined&quot;) {
		this.cache.parsedURLs = {};
	}
	var parsed = this.cache.parsedURLs;
	if (!parsed.hasOwnProperty(url)) {
		var parts = url.match(Echo.Utils.regexps.parseURL);
		parsed[url] = parts ? {
			&quot;scheme&quot;: parts[1] || &quot;&quot;,
			&quot;domain&quot;: parts[2] || &quot;&quot;,
			&quot;port&quot;: parts[3] || &quot;&quot;,
			&quot;path&quot;: parts[4] || &quot;/&quot;,
			&quot;query&quot;: parts[5] || &quot;&quot;,
			&quot;fragment&quot;: parts[6] || &quot;&quot;
		} : undefined;
	}
	return parsed[url];
};

<span id='Echo-Utils-static-method-getVisibleColor'>/**
</span> * @static
 * Method returning original visible color of the element.
 *
 * This function traverses the element parents recoursively to determine
 * original visible color of the element.It returns `transparent` string
 * if background-color of the element and its parents is not specified.
 *
 *     // HTML template
 *     var template =
 *         &#39;&lt;div class=&quot;container&quot;&gt;&#39; +
 *             &#39;&lt;div class=&quot;header&quot; style=&quot;background-color: green;&quot;&gt;header&lt;/div&gt;&#39; +
 *             &#39;&lt;div class=&quot;content&quot; style=&quot;background-color: red;&quot;&gt;&#39; +
 *                 &#39;&lt;div class=&quot;section1&quot;&gt;&lt;/div&gt;&#39; +
 *                 &#39;&lt;div class=&quot;section2&quot;&gt;&lt;/div&gt;&#39; +
 *             &#39;&lt;/div&gt;&#39; +
 *             &#39;&lt;div class=&quot;footer&quot;&gt;footer&lt;/div&gt;&#39; +
 *         &#39;&lt;/div&gt;&#39;;
 *
 *     Echo.Utils.getVisibleColor( $(&quot;.header&quot;, template) ); // returns &quot;rgb(0, 128, 0)&quot;
 *     Echo.Utils.getVisibleColor( $(&quot;.section1&quot;, template) ); // returns &quot;rgb(255, 0, 0)&quot;
 *     Echo.Utils.getVisibleColor( $(&quot;.footer&quot;, template) ); // returns &quot;transparent&quot;
 *
 * @param {HTMLElement} element
 * HTML element which visible color is being determined.
 *
 * @return {String}
 * Visible color.
 */
Echo.Utils.getVisibleColor = function(element) {
	// calculate visible color of element (transparent is not visible)
	var color;
	do {
		color = element.css(&quot;backgroundColor&quot;);
		if (color !== &quot;&quot; &amp;&amp; color !== &quot;transparent&quot; &amp;&amp; !/rgba\((0,\s*){3}0\)/.test(color) || $.nodeName(element.get(0), &quot;body&quot;)) {
			break;
		}
		element = element.parent();
	} while (element);
	return color || &quot;transparent&quot;;
};

<span id='Echo-Utils-static-method-timestampFromW3CDTF'>/**
</span> * @static
 * Method to convert datetime value from string representation to numeric timestamp.
 *
 *     Echo.Utils.timestampFromW3CDTF(&quot;1998-02-08T09:27:30Z&quot;); // returns 886930050
 *     Echo.Utils.timestampFromW3CDTF(&quot;1998-02-08T09:27:30.733Z&quot;); // returns 886930050.733
 *
 * The method can correctly parse any date format supported by user&#39;s browser.
 * However ISO 8601 format is understood independing of native support.
 * See [W3C Note](http://www.w3.org/TR/NOTE-datetime) for description of supported ISO 8601 subset.
 * Other suitable date formats are described in [RFC2822 Section 3.3](http://tools.ietf.org/html/rfc2822#page-14)
 * and in [MSDN topic](http://msdn.microsoft.com/en-us/library/ff743760.aspx).
 *
 * @param {String} datetime
 * String containing datetime value to be converted.
 *
 * @return {Number}
 * UNIX timestamp.
 */
Echo.Utils.timestampFromW3CDTF = function(datetime) {
	var time = Date.parse(datetime);
	if (isNaN(time)) {
		var parts = [&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hours&quot;, &quot;minutes&quot;, &quot;seconds&quot;, &quot;milliseconds&quot;];
		var matches = datetime.match(Echo.Utils.regexps.w3cdtf);
		if (!matches) {
			return undefined;
		}
		var dt = Echo.Utils.foldl({}, parts, function(key, acc, id) {
			acc[key] = +matches[id + 1] || 0;
		});
		var timeZone = matches.slice(parts.length + 1);
		if (timeZone[0]) {
			dt.hours = dt.hours - (timeZone[0] + timeZone[1]);
			dt.minutes = dt.minutes - (timeZone[0] + timeZone[2]);
		}
		time = Date.UTC(
			dt.year,
			dt.month ? dt.month - 1 : dt.month,
			dt.day || 1,
			dt.hours,
			dt.minutes,
			dt.seconds,
			dt.milliseconds
		);
		return isNaN(time)
			? undefined
			: time / 1000;
	}
	return time / 1000;
};

<span id='Echo-Utils-static-method-isMobileDevice'>/**
</span> * @static
 * Method to determine that mobile device is used.
 *
 * The function determines by navigator.userAgent that mobile device is used.
 *
 * @return {Boolean}
 * True if mobile device is used, false if not.
 */
Echo.Utils.isMobileDevice = function() {
	// we can calculate it once and use the cached value
	// in other calls since user agent will not be changed
	if (typeof this.cache.isMobileDevice === &quot;undefined&quot;) {
		this.cache.isMobileDevice = this.regexps.mobileUA.test(navigator.userAgent);
	}
	return this.cache.isMobileDevice;
};

<span id='Echo-Utils-static-method-getUniqueString'>/**
</span> * @static
 * Method returning a unique random string.
 *
 * This function returns a unique string specifying the number of milliseconds between
 * midnight January 1, 1970 (GMT) and the current time plus a random number.
 *
 *     Echo.Utils.getUniqueString(); // returns something like &quot;134086853327622290480640764643&quot;
 *
 * @return {String}
 * Unique random string.
 */
Echo.Utils.getUniqueString = function() {
	return (new Date()).valueOf() + Math.random().toString().substr(2);
};

<span id='Echo-Utils-static-method-inherit'>/**
</span> * @static
 * Method which allows to inherit the object from another object.
 *
 * This function performs prototype inheritance of the JS objects.
 *
 * @param {Object} parent
 * Class which should be used as a parent for the first class.
 *
 * @param {Object} child
 * Class which should be entended.
 *
 * @return {Object}
 * Resulting class.
 */
Echo.Utils.inherit = function(parent, child) {
	var F = function() {};
	child = child || function() {};
	F.prototype = parent.prototype;
	child.prototype = new F();
	child.prototype.constructor = child;
	child.parent = parent.prototype;
	return child;
};

<span id='Echo-Utils-static-method-getComponent'>/**
</span> * @static
 * Method to acquire a class reference by the JS class name.
 *
 * This function returns the reference to the corresponding JS class defined
 * on the page.
 *
 * @param {String} name
 * Name of the component which we need to access.
 *
 * @return {Object}
 * Reference to the necessary JS class.
 */
Echo.Utils.getComponent = function(name) {
	return Echo.Utils.get(window, name);
};

<span id='Echo-Utils-static-method-isComponentDefined'>/**
</span> * @static
 * Method which allows to check whether a given component was defined
 * on the page.
 *
 * This function returns the boolean value which represents whether
 * a given component is defined on the page.
 *
 * @param {String} name
 * Component name which needs to be checked.
 *
 * @return {Boolean}
 * True/false if the component was or wasn&#39;t found respectively.
 */
Echo.Utils.isComponentDefined = function(name) {
	return !!Echo.Utils.getComponent(name);
};

<span id='Echo-Utils-static-method-loadImage'>/**
</span> * @static
 * Method which loads image.
 *
 * This function returns image HTML element with source attribute that
 * equals first argument. If the image is not available then this function
 * loads the default image that is passed as a second argument.
 *
 * @param {Object} args
 * The object which contains attributes for loading image.
 *
 * @param {String} args.image
 * The URL of the image to be loaded.
 *
 * @param {String} [args.defaultImage]
 * The URL of the default image.
 *
 * @param {Function} [args.onload]
 * The callback which fires when image is loaded.
 *
 * @param {Function} [args.onerror]
 * The callback which fires when loading image fails.
 *
 * @return {HTMLElement}
 * Image HTML element.
 */
Echo.Utils.loadImage = function(args) {
	var url = args.image || args.defaultImage;
	var img = $(&quot;&lt;img&gt;&quot;);
	img.one({
		&quot;error&quot;: args.onerror || function() {
			if (args.defaultImage &amp;&amp; url !== args.defaultImage) {
				img.attr(&quot;src&quot;, args.defaultImage);
			}
		},
		&quot;load&quot;: args.onload || $.noop
	});
	return img.attr(&quot;src&quot;, url);
};

<span id='Echo-Utils-static-method-hyperlink'>/**
</span> * @static
 * Creates the HTML &amp;lt;a&gt; tag with the provided attribute names/values
 *
 * @param {Object} data
 * Hyperlink tag attribute key/value pairs, some of them are:
 *
 * @param {String} [data.caption]
 * Visible text for the hyperlink.
 *
 * @param {String} [data.href=&quot;javascript:void(0)&quot;]
 * Hyperlink URL.
 *
 * @param {String} [data.target]
 * Target window.
 *
 * @param {Object} options
 * Configurable options affecting hyperlink behavior.
 *
 * @param {Boolean} [options.openInNewWindow=false]
 * Specifies whether this should be opened in a separate window or not.
 *
 * @param {Boolean} [options.skipEscaping=false]
 * Specifies whether href value should be htmlized or not.
 *
 * @return {String}
 * HTML string for &amp;lt;a&gt; tag.
 */
Echo.Utils.hyperlink = function(data, options) {
	data = $.extend({}, data);
	options = $.extend({}, options);
	var caption = data.caption || &quot;&quot;;
	delete data.caption;
	if (options.openInNewWindow &amp;&amp; !data.target) {
		data.target = &quot;_blank&quot;;
	}
	if (!options.skipEscaping) {
		data.href = Echo.Utils.htmlize(data.href);
	}
	data.href = data.href || &quot;javascript:void(0)&quot;;
	var attributes = Echo.Utils.foldl([], data, function(value, acc, key) {
		acc.push(key + &#39;=&quot;&#39; + value + &#39;&quot;&#39;);
	});
	return &quot;&lt;a &quot; + attributes.join(&quot; &quot;) + &quot;&gt;&quot; + caption + &quot;&lt;/a&gt;&quot;;
};

<span id='Echo-Utils-static-method-log'>/**
</span> * @static
 * Function to log info/error message to the browser console in a unified format
 *
 * @param {Object} data
 * Defines the properties of the message which should be displayed.
 *
 * @param {String} data.message
 * Text description of the message which should be logged.
 *
 * @param {String} [data.component=&quot;Echo SDK&quot;]
 * Name of the component which produced the message.
 *
 * @param {String} [data.type=&quot;info&quot;]
 * Type/severity of the message.
 *
 * @param {String} [data.args]
 * Extra arguments to log.
 */
Echo.Utils.log = function(data) {
	if (!(window.console &amp;&amp; console.log &amp;&amp; data &amp;&amp; data.message)) {
		return;
	}
	console.log(
		&quot;[&quot; + (data.component || &quot;Echo SDK&quot;) + &quot;]&quot;,
		(data.type || &quot;info&quot;), &quot;:&quot;, data.message, &quot; | args: &quot;, data.args
	);
};

<span id='Echo-Utils-static-method-parallelCall'>/**
</span> * @static
 * Function to call the functions from the list and call callback function
 * after it. Functions are called async. For sync calls use Echo.Utils.sequentialCall
 *
 * @param {Array} actions
 * List of functions to be called.
 *
 * @param {Function} [callback]
 * Callback function to be called after functions processing.
 */
Echo.Utils.parallelCall = function(actions, callback) {
	if (!actions || !actions.length) {
		callback &amp;&amp; callback();
		return;
	}
	var remaining = actions.length;
	$.map(actions, function(action) {
		action(function() {
			if (!--remaining) {
				callback &amp;&amp; callback();
			}
		});
	});
};

<span id='Echo-Utils-static-method-sequentialCall'>/**
</span> * @static
 * Function to call the functions from the list sequentially and call callback
 * function after it.
 *
 * @param {Array} actions
 * List of functions to be called sequentially.
 *
 * @param {Function} [callback]
 * Callback function to be called after functions processing.
 */
Echo.Utils.sequentialCall = function(actions, callback) {
	if (!actions || !actions.length) {
		callback &amp;&amp; callback();
		return;
	}
	actions.shift()(function() {
		Echo.Utils.sequentialCall(actions, callback);
	});
};

<span id='Echo-Utils-static-method-capitalize'>/**
</span> * @static
 * Function used to replace the first character in the words with the uppercase character.
 *
 * @param {String} string
 * String of some words
 */
Echo.Utils.capitalize = function(string) {
	return string.replace(/\b[a-z]/g, function(match) {
		return match.toUpperCase();
	});
};

<span id='Echo-Utils-static-method-substitute'>/**
</span> * @static
 * Templater function which compiles the given template using the provided data.
 *
 * Function can be used widely for html templates processing or any other action
 * requiring string interspersion.
 *
 * @param {Object} args
 * Specifies substitution process and parameters.
 *
 * @param {String} args.template
 * Template containing placeholders used for data interspersion.
 *
 * @param {Object} [args.data]
 * Data used in the template compilation.
 *
 * @param {Boolean} [args.strict]
 * Specifies whether the template should be replaced with the corresponding value,
 * preserving the replacement value type.
 *
 * @param {Object} [args.instructions]
 * Object containing the list of extra instructions to be applied during template compilation.
 *
 * @param {Function} [args.normalizer]
 * Allows to normalize data values before putting them into template. This function
 * is not applied if args.strict is set to *true*.
 *
 * @param {Mixed} args.normalizer.value
 * Value to normalize.
 *
 * @param {String} args.normalizer.string
 * The whole template string.
 *
 * @param {Number} args.normalizer.pos
 * Placeholder position inside the template string.
 *
 * @param {Mixed} args.normalizer.return
 * Normalized value.
 *
 * @return {String}
 * Compiled string value.
 */
Echo.Utils.substitute = function(args) {
	var utils = this;
	var template = args.template;
	var substitutions = {
		&quot;data&quot;: function(key, defaults) {
			return utils.get(args.data, key, defaults);
		}
	};
	var instructions = args.instructions
		? $.extend(substitutions, args.instructions)
		: substitutions;

	if (typeof utils.cache.regexps === &quot;undefined&quot;) {
		var regex = utils.regexps.templateSubstitution;
		utils.cache.regexps = {
			&quot;strict&quot;: new RegExp(&quot;^&quot; + regex + &quot;$&quot;, &quot;i&quot;),
			&quot;single&quot;: new RegExp(regex, &quot;i&quot;),
			&quot;multiple&quot;: new RegExp(regex, &quot;ig&quot;)
		};
	}

	// checking if we need to execute in a strict mode,
	// i.e. whether to keep the substitution value type or not
	if (args.strict &amp;&amp; utils.cache.regexps.strict.test(template)) {
		var match = utils.cache.regexps.single.exec(template);
		if (match &amp;&amp; match[1] &amp;&amp; instructions[match[1]]) {
			return instructions[match[1]](match[2]);
		}
	}

	var normalizer = args.normalizer || function(v) { return v; };

	// perform regular string substitution
	return template.replace(utils.cache.regexps.multiple, function(match, key, value, pos, str) {
		if (!instructions[key]) return match;
		var result = instructions[key](value, &quot;&quot;);
		var allowed = {&quot;number&quot;: true, &quot;string&quot;: true, &quot;boolean&quot;: true};
		return allowed[typeof result]
			? normalizer(result, str, pos)
			: &quot;&quot;;
	});
};

<span id='Echo-Utils-static-method-invoke'>/**
</span> * @static
 * Function which checks if the value passed as a first argument is a function and executes
 * it in the given context. If the first argument has different type, it&#39;s returned as is.
 *
 * @param {Mixed} mixed
 * The value which should be checked and executed in case of a function type.
 *
 * @param {Object} context
 * Context in which the function should be executed.
 *
 * @return {Mixed}
 * The result of the function call in case the first argument is a function
 * or the first argument as is otherwise.
 */
Echo.Utils.invoke = function(mixed, context) {
	return $.isFunction(mixed)
		? context ? mixed.call(context) : mixed()
		: mixed;
};

<span id='Echo-Utils-static-method-debounce'>/**
</span> * @static
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds.
 * Basically it&#39;s a copy from underscore v1.6.0.
 *
 * @param {Function} func
 * Function to be debounced.
 *
 * @param {Number} wait
 * Number of milliseconds to delay the execution for.
 *
 * @param {Boolean} [immediate]
 * If passed, the function is triggered on the leading edge,
 * instead of the trailing.
 */
Echo.Utils.debounce = function(func, wait, immediate) {
	var timeout, args, context, timestamp, result;
	var now = Date.now || function() {
		return (new Date()).getTime();
	};
	var later = function() {
		var last = now() - timestamp;
		if (last &lt; wait &amp;&amp; last &gt; 0) {
			timeout = setTimeout(later, wait - last);
		} else {
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				if (!timeout) {
					context = args = null;
				}
			}
		}
	};
	return function() {
		context = this;
		args = arguments;
		timestamp = now();
		var callNow = immediate &amp;&amp; !timeout;
		if (!timeout) {
			timeout = setTimeout(later, wait);
		}
		if (callNow) {
			result = func.apply(context, args);
			context = args = null;
		}
		return result;
	};
};

<span id='Echo-Utils-static-method-safelyExecute'>/**
</span> * @static
 * Function which executes another function in the try/catch block.
 * If the given function completed its execution without throwing an exception,
 * then the &quot;safelyExecute&quot; returns result of that function execution.
 * Otherwise, the &quot;safelyExecute&quot; catches an exception and prints the
 * message to the console using the Echo.Utils#log function.
 * It is useful in case you want to avoid execution flow interruption
 * by the code which might potentially throw an exception.
 *
 *		// executes function without arguments and context
 *		Echo.Utils.safelyExecute(function() {});
 *		// returns undefined
 *
 *		// executes function with one argument &amp; without context
 *		Echo.Utils.safelyExecute(function() {}, &quot;string param&quot;);
 *		// returns undefined
 *
 *		someObject = {
 *			&quot;param&quot;: &quot;some string&quot;
 *		};
 *
 *		someObject.fn = function(a, b) {
 *			return [this.param, a, b];
 *		};
 *
 *		// executes function with arguments &amp; context
 *		Echo.Utils.safelyExecute(someObject.fn, [[], &quot;string param&quot;], someObject);
 *		// returns [&quot;some string&quot;, [], &quot;string param&quot;]
 *
 *		// executes the function which throws an exception
 *		Echo.Utils.safelyExecute(function() { throw &quot;Some error&quot;; });
 *		// returns undefined and prints &quot;Some error&quot; message to the console
 *
 * @param {Function} fn
 * Function to be excuted in the try/catch wrapper
 *
 * @param {Mixed} [args]
 * The argument type might vary depending on the use-case:
 *
 *  + undefined - in case the given function doesn&#39;t expect any arguments
 *  + array - if the function to be called accepts more than one argument
 *  + value as is - when the function expects only one argument.
 *
 * @param {Object} [context]
 * Context in which the function should be executed.
 *
 * @return {Mixed}
 * The result of a given function execution in case it was completed
 * without throwing an exception. Otherwise - the undefined is returned.
 */
Echo.Utils.safelyExecute = function(fn, args, context) {
	context = context || null;
	args = $.isArray(args)
		? args
		: typeof args === &quot;undefined&quot;
			? [] : [args];
	try {
		return fn.apply(context, args);
	} catch(e) {
		Echo.Utils.log({
			&quot;type&quot;: &quot;error&quot;,
			&quot;message&quot;: e.message || e,
			&quot;component&quot;: context instanceof Echo.Control ? context.name : &quot;&quot;
		});
	}
};

<span id='Echo-Utils-static-method-random'>/**
</span> * @static
 * Function which accepts two arguments (numbers) as a range and
 * generates a random number in the given range.
 *
 *		Echo.Utils.random(1, 5); // returns a random number in range of [1, 5]
 *
 * @param {Number} min
 * Number which is the lower limit of the range
 *
 * @param {Number} max
 * Number which is the upper limit of the range
 *
 * @return {Number}
 * Random number in the [min, max] range
 */
Echo.Utils.random = function(min, max) {
	return min + Math.floor(Math.random() * (max - min + 1));
};

<span id='Echo-Utils-static-method-deepEqual'>/**
</span> * @static
 * Performs deep comparison between two objects.
 *
 *		var a = {&quot;a&quot;: undefined, &quot;b&quot;: 1, &quot;c&quot;: {&quot;d&quot;: true}, &quot;e&quot;: [&quot;f&quot;, &quot;h&quot;]};
 *		var b = {&quot;a&quot;: undefined, &quot;b&quot;: 1, &quot;c&quot;: {&quot;d&quot;: true}, &quot;e&quot;: [&quot;f&quot;, &quot;h&quot;]};
 *		Echo.Utils.deepEqual(a, b); // returns true
 *
 *		var a = {&quot;a&quot;: undefined, &quot;b&quot;: 1, &quot;c&quot;: {&quot;d&quot;: false}, &quot;e&quot;: [&quot;f&quot;, &quot;h&quot;]};
 *		var b = {&quot;a&quot;: undefined, &quot;b&quot;: 1, &quot;c&quot;: {&quot;d&quot;: true}, &quot;e&quot;: [&quot;f&quot;, &quot;h&quot;]};
 *		Echo.Utils.deepEqual(a, b); // returns false
 *
 *		var a = {&quot;a&quot;: undefined, &quot;b&quot;: 1, &quot;c&quot;: {&quot;d&quot;: true}, &quot;e&quot;: {&quot;f&quot;: &quot;h&quot;}};
 *		var b = {&quot;a&quot;: undefined, &quot;b&quot;: 1, &quot;c&quot;: {&quot;d&quot;: true}, &quot;e&quot;: [&quot;f&quot;, &quot;h&quot;]};
 *		Echo.Utils.deepEqual(a, b); // returns false
 *
 * @param {Object} object1
 * Object to compare
 *
 * @param {Object} object2
 * Other object to compare
 *
 * @return {Boolean}
 * Returns true if objects are equal.
 */
Echo.Utils.deepEqual = function(a, b) {
	var aParents = [], bParents = [];
	var areEqual = function(a, b) {
		var aType = $.type(a);
		var bType = $.type(b);
		var aCircular = ~$.inArray(a, aParents);
		var bCircular = ~$.inArray(b, bParents);
		if (aType !== bType) return false;
		if (aCircular || bCircular) {
			return a === b || aCircular &amp;&amp; bCircular;
		}
		if (this[aType] &amp;&amp; !this[aType](a, b)) return false;
		return true;
	};
	var strictEqual = function(a, b) {
		return a === b;
	};
	var comparators = {
		&quot;number&quot;: strictEqual,
		&quot;string&quot;: strictEqual,
		&quot;boolean&quot;: strictEqual,
		&quot;array&quot;: function(a, b) {
			var l = a.length;
			if (l !== b.length) return false;
			aParents.push(a);
			bParents.push(b);
			for (var i = 0; i &lt; l; i++) {
				if (!areEqual.call(this, a[i], b[i])) return false;
			}
			return true;
		},
		&quot;object&quot;: function(a, b) {
			var i, aProps = [], bProps = [];
			aParents.push(a);
			bParents.push(b);
			for (i in a) {
				if (a.hasOwnProperty(i)) {
					aProps.push(i);
					if (!areEqual.call(this, a[i], b[i])) return false;
				}
			}
			for (i in b) {
				if (b.hasOwnProperty(i)) {
					bProps.push(i);
				}
			}
			return this.array(aProps.sort(), bProps.sort());
		}
	};
	return areEqual.call(comparators, a, b);
};

<span id='Echo-Utils-static-method-retry'>/**
</span> * @static
 * Function which executes another function passed as an argument
 * and allows to execute the same function multiple times
 * in case a previous attempt failed.
 *
 *		var def = $.Deferred();
 *		var fn = function() {
 *			setTimeout(function() {
 *				i++;
 *				def.reject();
 *			}, 100);
 *			return def.promise();
 *		};
 *		Echo.Utils.retry(fn).fail(function() {
 *			console.log(&quot;retries failed&quot;);
 *		});
 *
 * @param {Function} inputFn
 * Function which should be executed.
 * This function should return [promise object](http://api.jquery.com/promise/) which
 * describes the state of the executed function.
 *
 * @param {Object} [options]
 * Contains retrying machinery options.
 *
 * @param {Number} [options.times]
 * Describes maximum retries attempts.
 *
 * @param {Number} [options.ratio]
 * Positive number which will be used in the [exponential backoff](http://en.wikipedia.org/wiki/Exponential_backoff#An_example_of_an_exponential_back-off_algorithm)
 * algorithm.
 *
 * @param {Object} [ctx]
 * Context in which the function should be executed.
 *
 * @param {Array} [args]
 * Arguments to be passed to a given &quot;inputFn&quot; function at execution time.
 *
 * @return {Object}
 * Return [promise object](http://api.jquery.com/promise/)
 * which describes the final state of the function after retries.
 */
Echo.Utils.retry = function(inputFn, options, ctx, args) {
	options = options || {};
	args = args || [];
	var times = options.times || 1;
	var ratio = options.ratio;
	return (function retry(attempts) {
		return inputFn.apply(ctx, args).then(null, function() {
			var delay, output = $.Deferred();
			var next = function() {
				retry(attempts + 1)
					.then(output.resolve, output.reject);
			};
			if (times &gt; attempts) {
				if (typeof ratio !== &quot;undefined&quot;) {
					// simple exponential backoff algorithm
					delay = ratio * Echo.Utils.random(0, Math.pow(2, attempts));
					setTimeout(next, delay * 1000);
				} else {
					next();
				}
			} else {
				output.reject(arguments);
			}
			return output;
		});
	})(0);
};

<span id='Echo-Utils-static-method-promisify'>/**
</span> * @static
 * Wraps passed function with another function which returns a
 * [promise object](http://api.jquery.com/promise/) after invocation.
 *
 *		var promise = Echo.Utils.promisify(function(num, done) {
 *			if (num &lt; 0) {
 *				done({
 *					&quot;code&quot;: &quot;negative_number&quot;,
 *					&quot;msg&quot;: &quot;The number should be positive.&quot;
 *				});
 *			} else {
 *				done(null, num, Math.sqrt(num));
 *			}
 *		});
 *		// promise resolved
 *		promise(16).then(function(original, sqrt) {
 *			console.log(&quot;The square root of the num &quot; + original + &quot; is &quot; + sqrt);
 *		});
 *		// prints &quot;The square root of the num 16 is 4&quot;
 *
 *		// promise rejected
 *		promise(-6).fail(function(error) {
 *			console.log(&quot;The error is: &quot; + error.code);
 *		});
 *		// prints &quot;The error is: negative_number&quot;
 *
 * @param {Function} fn
 * Original function which will be wrapped.
 *
 * @param {Mixed} [fn.any_number_of_parameters]
 * Arbitrary number of parameters of the original function.
 *
 * @param {Function} fn.done
 * Callback function which should be executed as soon as the original function
 * is considered completed. It must be at the very end of `fn` function
 * parameter list.
 *
 * @param {Mixed} [fn.done.error]
 * If the value of this parameter is evaluated as `true` value, then promise
 * is considered resolved. Otherwise promise is rejected.
 *
 * @param {Mixed} [fn.done.any_number_of_parameters]
 * Arbitrary number of parameters which the promise will be resolved with.
 *
 * @param {Object} [ctx]
 * Context in which the function should be executed.
 *
 * @return {Function}
 * Wrapped function.
 */
Echo.Utils.promisify = function(fn, ctx) {
	return function() {
		var slice = Array.prototype.slice;
		var args = slice.call(arguments, 0, fn.length - 1);
		var promise = $.Deferred();
		args.push(function() {
			var results = slice.call(arguments);
			var error = results.shift();
			if (error) {
				promise.reject(error);
			} else {
				promise.resolve.apply(promise, results);
			}
		});
		fn.apply(ctx, args);
		return promise;
	};
};

<span id='Echo-Utils-static-method-pipe'>/**
</span> * @static
 * Provides an interface to pipe promises: it takes a [promise object](http://api.jquery.com/promise/)
 * and pipes it through the list of promisified functions. If promise object has an async nature,
 * then execution continues after the previous promise is either resolved or rejected.
 *
 *		var fn = function(o, callback) {
 *			o.count++;
 *			console.log(o.count);
 *			callback(null, o);
 *		};
 *		var promise = Echo.Utils.promisify(fn);
 *		Echo.Utils.pipe(
 *			$.Deferred().resolve({&quot;count&quot;: 0}),
 *			[promise, promise, promise]
 *		);
 *		// prints:
 *		//&quot;1&quot;
 *		//&quot;2&quot;
 *		//&quot;3&quot;
 *
 * @param {Object} [glue]
 * Promise object which can pass a value to the promises through the pipe.
 * This parameter can be omitted if there is no need to pass a specific value.
 *
 * @param {Array} [functions]
 * Contains promisified functions which can modify `glue` or generate new values.
 */
Echo.Utils.pipe = function() {
	var glue, functions;
	if (arguments.length === 1 &amp;&amp; $.isArray(arguments[0])) {
		glue = $.Deferred().resolve();
		functions = arguments[0];
	} else {
		glue = arguments[0];
		functions = arguments[1] || [];
	}
	for (var i = 0, n = functions.length; i &lt; n; i++) {
		glue = glue.then(functions[i]);
	}
	return glue;
};

// JS SDK can&#39;t guarantee proper UI elements rendering in quirks mode
// because the UI Framework (Twitter Bootstrap) doesn&#39;t support this mode.
// Adding the message about that to the browser console to let the user know.
if (document.compatMode === &quot;BackCompat&quot;) {
	Echo.Utils.log({
		&quot;type&quot;: &quot;error&quot;,
		&quot;message&quot;: &quot;Quirks mode is not supported by JS SDK. Please make sure that the page has a valid doctype.&quot;
	});
}

})(Echo.jQuery);
</pre>
</body>
</html>
