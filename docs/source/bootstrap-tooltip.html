<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/* ===========================================================
 * bootstrap-tooltip.js v2.3.2
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */


!function ($) {

  &quot;use strict&quot;; // jshint ;_;


 /* TOOLTIP PUBLIC CLASS DEFINITION
  * =============================== */

  var Tooltip = function (element, options) {
    this.init(&#39;tooltip&#39;, element, options)
  }

  Tooltip.prototype = {

    constructor: Tooltip

  , init: function (type, element, options) {
      var eventIn
        , eventOut
        , triggers
        , trigger
        , i

      this.type = type
      this.$element = $(element)
      this.options = this.getOptions(options)
      this.enabled = true

      triggers = this.options.trigger.split(&#39; &#39;)

      for (i = triggers.length; i--;) {
        trigger = triggers[i]
        if (trigger == &#39;click&#39;) {
          this.$element.on(&#39;click.&#39; + this.type, this.options.selector, $.proxy(this.toggle, this))
        } else if (trigger != &#39;manual&#39;) {
          eventIn = trigger == &#39;hover&#39; ? &#39;mouseenter&#39; : &#39;focus&#39;
          eventOut = trigger == &#39;hover&#39; ? &#39;mouseleave&#39; : &#39;blur&#39;
          this.$element.on(eventIn + &#39;.&#39; + this.type, this.options.selector, $.proxy(this.enter, this))
          this.$element.on(eventOut + &#39;.&#39; + this.type, this.options.selector, $.proxy(this.leave, this))
        }
      }

      this.options.selector ?
        (this._options = $.extend({}, this.options, { trigger: &#39;manual&#39;, selector: &#39;&#39; })) :
        this.fixTitle()
    }

  , getOptions: function (options) {
      options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options)

      if (options.delay &amp;&amp; typeof options.delay == &#39;number&#39;) {
        options.delay = {
          show: options.delay
        , hide: options.delay
        }
      }

      return options
    }

  , enter: function (e) {
      var defaults = $.fn[this.type].defaults
        , options = {}
        , self

      this._options &amp;&amp; $.each(this._options, function (key, value) {
        if (defaults[key] != value) options[key] = value
      }, this)

      self = $(e.currentTarget)[this.type](options).data(this.type)

      if (!self.options.delay || !self.options.delay.show) return self.show()

      clearTimeout(this.timeout)
      self.hoverState = &#39;in&#39;
      this.timeout = setTimeout(function() {
        if (self.hoverState == &#39;in&#39;) self.show()
      }, self.options.delay.show)
    }

  , leave: function (e) {
      var self = $(e.currentTarget)[this.type](this._options).data(this.type)

      if (this.timeout) clearTimeout(this.timeout)
      if (!self.options.delay || !self.options.delay.hide) return self.hide()

      self.hoverState = &#39;out&#39;
      this.timeout = setTimeout(function() {
        if (self.hoverState == &#39;out&#39;) self.hide()
      }, self.options.delay.hide)
    }

  , show: function () {
      var $tip
        , pos
        , actualWidth
        , actualHeight
        , placement
        , tp
        , e = $.Event(&#39;show&#39;)

      if (this.hasContent() &amp;&amp; this.enabled) {
        this.$element.trigger(e)
        if (e.isDefaultPrevented()) return
        $tip = this.tip()
        this.setContent()

        if (this.options.animation) {
          $tip.addClass(&#39;fade&#39;)
        }

        placement = typeof this.options.placement == &#39;function&#39; ?
          this.options.placement.call(this, $tip[0], this.$element[0]) :
          this.options.placement

        $tip
          .detach()
          .css({ top: 0, left: 0, display: &#39;block&#39; })

        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

        pos = this.getPosition()

        actualWidth = $tip[0].offsetWidth
        actualHeight = $tip[0].offsetHeight

        switch (placement) {
          case &#39;bottom&#39;:
            tp = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case &#39;top&#39;:
            tp = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2}
            break
          case &#39;left&#39;:
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth}
            break
          case &#39;right&#39;:
            tp = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
            break
        }

        this.applyPlacement(tp, placement)
        this.$element.trigger(&#39;shown&#39;)
      }
    }

  , applyPlacement: function(offset, placement){
      var $tip = this.tip()
        , width = $tip[0].offsetWidth
        , height = $tip[0].offsetHeight
        , actualWidth
        , actualHeight
        , delta
        , replace

      $tip
        .offset(offset)
        .addClass(placement)
        .addClass(&#39;in&#39;)

      actualWidth = $tip[0].offsetWidth
      actualHeight = $tip[0].offsetHeight

      if (placement == &#39;top&#39; &amp;&amp; actualHeight != height) {
        offset.top = offset.top + height - actualHeight
        replace = true
      }

      if (placement == &#39;bottom&#39; || placement == &#39;top&#39;) {
        delta = 0

        if (offset.left &lt; 0){
          delta = offset.left * -2
          offset.left = 0
          $tip.offset(offset)
          actualWidth = $tip[0].offsetWidth
          actualHeight = $tip[0].offsetHeight
        }

        this.replaceArrow(delta - width + actualWidth, actualWidth, &#39;left&#39;)
      } else {
        this.replaceArrow(actualHeight - height, actualHeight, &#39;top&#39;)
      }

      if (replace) $tip.offset(offset)
    }

  , replaceArrow: function(delta, dimension, position){
      this
        .arrow()
        .css(position, delta ? (50 * (1 - delta / dimension) + &quot;%&quot;) : &#39;&#39;)
    }

  , setContent: function () {
      var $tip = this.tip()
        , title = this.getTitle()

      $tip.find(&#39;.tooltip-inner&#39;)[this.options.html ? &#39;html&#39; : &#39;text&#39;](title)
      $tip.removeClass(&#39;fade in top bottom left right&#39;)
    }

  , hide: function () {
      var that = this
        , $tip = this.tip()
        , e = $.Event(&#39;hide&#39;)

      this.$element.trigger(e)
      if (e.isDefaultPrevented()) return

      $tip.removeClass(&#39;in&#39;)

      function removeWithAnimation() {
        var timeout = setTimeout(function () {
          $tip.off($.support.transition.end).detach()
        }, 500)

        $tip.one($.support.transition.end, function () {
          clearTimeout(timeout)
          $tip.detach()
        })
      }

      $.support.transition &amp;&amp; this.$tip.hasClass(&#39;fade&#39;) ?
        removeWithAnimation() :
        $tip.detach()

      this.$element.trigger(&#39;hidden&#39;)

      return this
    }

  , fixTitle: function () {
      var $e = this.$element
      if ($e.attr(&#39;title&#39;) || typeof($e.attr(&#39;data-original-title&#39;)) != &#39;string&#39;) {
        $e.attr(&#39;data-original-title&#39;, $e.attr(&#39;title&#39;) || &#39;&#39;).attr(&#39;title&#39;, &#39;&#39;)
      }
    }

  , hasContent: function () {
      return this.getTitle()
    }

  , getPosition: function () {
      var el = this.$element[0]
      return $.extend({}, (typeof el.getBoundingClientRect == &#39;function&#39;) ? el.getBoundingClientRect() : {
        width: el.offsetWidth
      , height: el.offsetHeight
      }, this.$element.offset())
    }

  , getTitle: function () {
      var title
        , $e = this.$element
        , o = this.options

      title = $e.attr(&#39;data-original-title&#39;)
        || (typeof o.title == &#39;function&#39; ? o.title.call($e[0]) :  o.title)

      return title
    }

  , tip: function () {
      return this.$tip = this.$tip || $(this.options.template)
    }

  , arrow: function(){
      return this.$arrow = this.$arrow || this.tip().find(&quot;.tooltip-arrow&quot;)
    }

  , validate: function () {
      if (!this.$element[0].parentNode) {
        this.hide()
        this.$element = null
        this.options = null
      }
    }

  , enable: function () {
      this.enabled = true
    }

  , disable: function () {
      this.enabled = false
    }

  , toggleEnabled: function () {
      this.enabled = !this.enabled
    }

  , toggle: function (e) {
      var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this
      self.tip().hasClass(&#39;in&#39;) ? self.hide() : self.show()
    }

  , destroy: function () {
      this.hide().$element.off(&#39;.&#39; + this.type).removeData(this.type)
    }

  }


 /* TOOLTIP PLUGIN DEFINITION
  * ========================= */

  var old = $.fn.tooltip

  $.fn.tooltip = function ( option ) {
    return this.each(function () {
      var $this = $(this)
        , data = $this.data(&#39;tooltip&#39;)
        , options = typeof option == &#39;object&#39; &amp;&amp; option
      if (!data) $this.data(&#39;tooltip&#39;, (data = new Tooltip(this, options)))
      if (typeof option == &#39;string&#39;) data[option]()
    })
  }

  $.fn.tooltip.Constructor = Tooltip

  $.fn.tooltip.defaults = {
    animation: true
  , placement: &#39;top&#39;
  , selector: false
  , template: &#39;&lt;div class=&quot;tooltip&quot;&gt;&lt;div class=&quot;tooltip-arrow&quot;&gt;&lt;/div&gt;&lt;div class=&quot;tooltip-inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;
  , trigger: &#39;hover focus&#39;
  , title: &#39;&#39;
  , delay: 0
  , html: false
  , container: false
  }


 /* TOOLTIP NO CONFLICT
  * =================== */

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(window.jQuery);
</pre>
</body>
</html>
